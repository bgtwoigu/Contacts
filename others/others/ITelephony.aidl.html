<html>
<head>
  <title>ITelephony.aidl</title>
  <basefont face="Microsoft YaHei" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/301769 (zh-CN); Windows/6.3.9600 (Win64);"/>
  <style>
    body, td {
      font-family: Microsoft YaHei;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="998"/>
<h1>ITelephony.aidl</h1>

<div>
<span><div>/*</div><div> * Copyright (C) 2007 The Android Open Source Project</div><div> *</div><div> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</div><div> * you may not use this file except in compliance with the License.</div><div> * You may obtain a copy of the License at</div><div> *</div><div> *      http://www.apache.org/licenses/LICENSE-2.0</div><div> *</div><div> * Unless required by applicable law or agreed to in writing, software</div><div> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</div><div> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</div><div> * See the License for the specific language governing permissions and</div><div> * limitations under the License.</div><div> */</div><div><br/></div><div>package com.android.internal.telephony;</div><div><br/></div><div>import android.content.Intent;</div><div>import android.os.Bundle;</div><div>import android.telephony.CellInfo;</div><div>import android.telephony.IccOpenLogicalChannelResponse;</div><div>import android.telephony.NeighboringCellInfo;</div><div>import android.telephony.RadioAccessFamily;</div><div>import java.util.List;</div><div><br/></div><div><br/></div><div>/**</div><div> * Interface used to interact with the phone.  Mostly this is used by the</div><div> * TelephonyManager class.  A few places are still using this directly.</div><div> * Please clean them up if possible and use TelephonyManager instead.</div><div> *</div><div> * {@hide}</div><div> */</div><div>interface ITelephony {</div><div><br/></div><div>    /**</div><div>     * Dial a number. This doesn't place the call. It displays</div><div>     * the Dialer screen.</div><div>     * @param number the number to be dialed. If null, this</div><div>     * would display the Dialer screen with no number pre-filled.</div><div>     */</div><div>    void dial(String number);</div><div><br/></div><div>    /**</div><div>     * Place a call to the specified number.</div><div>     * @param number the number to be called.</div><div>     */</div><div>    void call(String callingPackage, String number);</div><div><br/></div><div>    /**</div><div>     * End call if there is a call in progress, otherwise does nothing.</div><div>     *</div><div>     * @return whether it hung up</div><div>     */</div><div>    boolean endCall();</div><div><br/></div><div>    /**</div><div>     * End call on particular subId or go to the Home screen</div><div>     * @param subId user preferred subId.</div><div>     * @return whether it hung up</div><div>     */</div><div>    boolean endCallForSubscriber(int subId);</div><div><br/></div><div>    /**</div><div>     * Answer the currently-ringing call.</div><div>     *</div><div>     * If there's already a current active call, that call will be</div><div>     * automatically put on hold.  If both lines are currently in use, the</div><div>     * current active call will be ended.</div><div>     *</div><div>     * TODO: provide a flag to let the caller specify what policy to use</div><div>     * if both lines are in use.  (The current behavior is hardwired to</div><div>     * &quot;answer incoming, end ongoing&quot;, which is how the CALL button</div><div>     * is specced to behave.)</div><div>     *</div><div>     * TODO: this should be a oneway call (especially since it's called</div><div>     * directly from the key queue thread).</div><div>     */</div><div>    void answerRingingCall();</div><div><br/></div><div>    /**</div><div>     * Answer the currently-ringing call on particular subId .</div><div>     *</div><div>     * If there's already a current active call, that call will be</div><div>     * automatically put on hold.  If both lines are currently in use, the</div><div>     * current active call will be ended.</div><div>     *</div><div>     * TODO: provide a flag to let the caller specify what policy to use</div><div>     * if both lines are in use.  (The current behavior is hardwired to</div><div>     * &quot;answer incoming, end ongoing&quot;, which is how the CALL button</div><div>     * is specced to behave.)</div><div>     *</div><div>     * TODO: this should be a oneway call (especially since it's called</div><div>     * directly from the key queue thread).</div><div>     */</div><div>    void answerRingingCallForSubscriber(int subId);</div><div><br/></div><div>    /**</div><div>     * Silence the ringer if an incoming call is currently ringing.</div><div>     * (If vibrating, stop the vibrator also.)</div><div>     *</div><div>     * It's safe to call this if the ringer has already been silenced, or</div><div>     * even if there's no incoming call.  (If so, this method will do nothing.)</div><div>     *</div><div>     * TODO: this should be a oneway call too (see above).</div><div>     *       (Actually *all* the methods here that return void can</div><div>     *       probably be oneway.)</div><div>     */</div><div>    void silenceRinger();</div><div><br/></div><div>    /**</div><div>     * Check if we are in either an active or holding call</div><div>     * @return true if the phone state is OFFHOOK.</div><div>     */</div><div>    boolean isOffhook();</div><div><br/></div><div>    /**</div><div>     * Check if a particular subId has an active or holding call</div><div>     *</div><div>     * @param subId user preferred subId.</div><div>     * @return true if the phone state is OFFHOOK.</div><div>     */</div><div>    boolean isOffhookForSubscriber(int subId);</div><div><br/></div><div>    /**</div><div>     * Check if an incoming phone call is ringing or call waiting</div><div>     * on a particular subId.</div><div>     *</div><div>     * @param subId user preferred subId.</div><div>     * @return true if the phone state is RINGING.</div><div>     */</div><div>    boolean isRingingForSubscriber(int subId);</div><div><br/></div><div>    /**</div><div>     * Check if an incoming phone call is ringing or call waiting.</div><div>     * @return true if the phone state is RINGING.</div><div>     */</div><div>    boolean isRinging();</div><div><br/></div><div>    /**</div><div>     * Check if the phone is idle.</div><div>     * @return true if the phone state is IDLE.</div><div>     */</div><div>    boolean isIdle();</div><div><br/></div><div>    /**</div><div>     * Check if the phone is idle on a particular subId.</div><div>     *</div><div>     * @param subId user preferred subId.</div><div>     * @return true if the phone state is IDLE.</div><div>     */</div><div>    boolean isIdleForSubscriber(int subId);</div><div><br/></div><div>    /**</div><div>     * Check to see if the radio is on or not.</div><div>     * @return returns true if the radio is on.</div><div>     */</div><div>    boolean isRadioOn();</div><div><br/></div><div>    /**</div><div>     * Check to see if the radio is on or not on particular subId.</div><div>     * @param subId user preferred subId.</div><div>     * @return returns true if the radio is on.</div><div>     */</div><div>    boolean isRadioOnForSubscriber(int subId);</div><div><br/></div><div>    /**</div><div>     * Check if the SIM pin lock is enabled.</div><div>     * @return true if the SIM pin lock is enabled.</div><div>     */</div><div>    boolean isSimPinEnabled();</div><div><br/></div><div>    /**</div><div>     * Supply a pin to unlock the SIM.  Blocks until a result is determined.</div><div>     * @param pin The pin to check.</div><div>     * @return whether the operation was a success.</div><div>     */</div><div>    boolean supplyPin(String pin);</div><div><br/></div><div>    /**</div><div>     * Supply a pin to unlock the SIM for particular subId.</div><div>     * Blocks until a result is determined.</div><div>     * @param pin The pin to check.</div><div>     * @param subId user preferred subId.</div><div>     * @return whether the operation was a success.</div><div>     */</div><div>    boolean supplyPinForSubscriber(int subId, String pin);</div><div><br/></div><div>    /**</div><div>     * Supply puk to unlock the SIM and set SIM pin to new pin.</div><div>     *  Blocks until a result is determined.</div><div>     * @param puk The puk to check.</div><div>     *        pin The new pin to be set in SIM</div><div>     * @return whether the operation was a success.</div><div>     */</div><div>    boolean supplyPuk(String puk, String pin);</div><div><br/></div><div>    /**</div><div>     * Supply puk to unlock the SIM and set SIM pin to new pin.</div><div>     *  Blocks until a result is determined.</div><div>     * @param puk The puk to check.</div><div>     *        pin The new pin to be set in SIM</div><div>     * @param subId user preferred subId.</div><div>     * @return whether the operation was a success.</div><div>     */</div><div>    boolean supplyPukForSubscriber(int subId, String puk, String pin);</div><div><br/></div><div>    /**</div><div>     * Supply a pin to unlock the SIM.  Blocks until a result is determined.</div><div>     * Returns a specific success/error code.</div><div>     * @param pin The pin to check.</div><div>     * @return retValue[0] = Phone.PIN_RESULT_SUCCESS on success. Otherwise error code</div><div>     *         retValue[1] = number of attempts remaining if known otherwise -1</div><div>     */</div><div>    int[] supplyPinReportResult(String pin);</div><div><br/></div><div>    /**</div><div>     * Supply a pin to unlock the SIM.  Blocks until a result is determined.</div><div>     * Returns a specific success/error code.</div><div>     * @param pin The pin to check.</div><div>     * @return retValue[0] = Phone.PIN_RESULT_SUCCESS on success. Otherwise error code</div><div>     *         retValue[1] = number of attempts remaining if known otherwise -1</div><div>     */</div><div>    int[] supplyPinReportResultForSubscriber(int subId, String pin);</div><div><br/></div><div>    /**</div><div>     * Supply puk to unlock the SIM and set SIM pin to new pin.</div><div>     * Blocks until a result is determined.</div><div>     * Returns a specific success/error code</div><div>     * @param puk The puk to check</div><div>     *        pin The pin to check.</div><div>     * @return retValue[0] = Phone.PIN_RESULT_SUCCESS on success. Otherwise error code</div><div>     *         retValue[1] = number of attempts remaining if known otherwise -1</div><div>     */</div><div>    int[] supplyPukReportResult(String puk, String pin);</div><div><br/></div><div>    /**</div><div>     * Supply puk to unlock the SIM and set SIM pin to new pin.</div><div>     * Blocks until a result is determined.</div><div>     * Returns a specific success/error code</div><div>     * @param puk The puk to check</div><div>     *        pin The pin to check.</div><div>     * @return retValue[0] = Phone.PIN_RESULT_SUCCESS on success. Otherwise error code</div><div>     *         retValue[1] = number of attempts remaining if known otherwise -1</div><div>     */</div><div>    int[] supplyPukReportResultForSubscriber(int subId, String puk, String pin);</div><div><br/></div><div>    /**</div><div>     * Handles PIN MMI commands (PIN/PIN2/PUK/PUK2), which are initiated</div><div>     * without SEND (so &lt;code&gt;dial&lt;/code&gt; is not appropriate).</div><div>     *</div><div>     * @param dialString the MMI command to be executed.</div><div>     * @return true if MMI command is executed.</div><div>     */</div><div>    boolean handlePinMmi(String dialString);</div><div><br/></div><div>    /**</div><div>     * Handles PIN MMI commands (PIN/PIN2/PUK/PUK2), which are initiated</div><div>     * without SEND (so &lt;code&gt;dial&lt;/code&gt; is not appropriate) for</div><div>     * a particular subId.</div><div>     * @param dialString the MMI command to be executed.</div><div>     * @param subId user preferred subId.</div><div>     * @return true if MMI command is executed.</div><div>     */</div><div>    boolean handlePinMmiForSubscriber(int subId, String dialString);</div><div><br/></div><div>    /**</div><div>     * Toggles the radio on or off.</div><div>     */</div><div>    void toggleRadioOnOff();</div><div><br/></div><div>    /**</div><div>     * Toggles the radio on or off on particular subId.</div><div>     * @param subId user preferred subId.</div><div>     */</div><div>    void toggleRadioOnOffForSubscriber(int subId);</div><div><br/></div><div>    /**</div><div>     * Set the radio to on or off</div><div>     */</div><div>    boolean setRadio(boolean turnOn);</div><div><br/></div><div>    /**</div><div>     * Set the radio to on or off on particular subId.</div><div>     * @param subId user preferred subId.</div><div>     */</div><div>    boolean setRadioForSubscriber(int subId, boolean turnOn);</div><div><br/></div><div>    /**</div><div>     * Set the radio to on or off unconditionally</div><div>     */</div><div>    boolean setRadioPower(boolean turnOn);</div><div><br/></div><div>    /**</div><div>     * Request to update location information in service state</div><div>     */</div><div>    void updateServiceLocation();</div><div><br/></div><div>    /**</div><div>     * Request to update location information for a subscrition in service state</div><div>     * @param subId user preferred subId.</div><div>     */</div><div>    void updateServiceLocationForSubscriber(int subId);</div><div><br/></div><div>    /**</div><div>     * Enable location update notifications.</div><div>     */</div><div>    void enableLocationUpdates();</div><div><br/></div><div>    /**</div><div>     * Enable location update notifications.</div><div>     * @param subId user preferred subId.</div><div>     */</div><div>    void enableLocationUpdatesForSubscriber(int subId);</div><div><br/></div><div>    /**</div><div>     * Disable location update notifications.</div><div>     */</div><div>    void disableLocationUpdates();</div><div><br/></div><div>    /**</div><div>     * Disable location update notifications.</div><div>     * @param subId user preferred subId.</div><div>     */</div><div>    void disableLocationUpdatesForSubscriber(int subId);</div><div><br/></div><div>    /**</div><div>     * Allow mobile data connections.</div><div>     */</div><div>    boolean enableDataConnectivity();</div><div><br/></div><div>    /**</div><div>     * Disallow mobile data connections.</div><div>     */</div><div>    boolean disableDataConnectivity();</div><div><br/></div><div>    /**</div><div>     * Report whether data connectivity is possible.</div><div>     */</div><div>    boolean isDataConnectivityPossible();</div><div><br/></div><div>    Bundle getCellLocation();</div><div><br/></div><div>    /**</div><div>     * Returns the neighboring cell information of the device.</div><div>     */</div><div>    List&lt;NeighboringCellInfo&gt; getNeighboringCellInfo(String callingPkg);</div><div><br/></div><div>     int getCallState();</div><div><br/></div><div>    /**</div><div>     * Returns the call state for a subId.</div><div>     */</div><div>     int getCallStateForSubscriber(int subId);</div><div><br/></div><div>    /**</div><div>     * Returns the data activity.</div><div>     */</div><div>     int getDataActivity();</div><div><br/></div><div>    /**</div><div>     * Returns the data activity for a subId.</div><div>     */</div><div>     int getDataActivityForSubscriber(int subId);</div><div><br/></div><div>    /**</div><div>     * Returns the data state.</div><div>     */</div><div>     int getDataState();</div><div><br/></div><div>    /**</div><div>     * Returns the data state for a subId.</div><div>     */</div><div>     int getDataStateForSubscriber(int subId);</div><div><br/></div><div>    /**</div><div>     * Returns the current active phone type as integer.</div><div>     * Returns TelephonyManager.PHONE_TYPE_CDMA if RILConstants.CDMA_PHONE</div><div>     * and TelephonyManager.PHONE_TYPE_GSM if RILConstants.GSM_PHONE</div><div>     */</div><div>    int getActivePhoneType();</div><div><br/></div><div>    /**</div><div>     * Returns the current active phone type as integer for particular subId.</div><div>     * Returns TelephonyManager.PHONE_TYPE_CDMA if RILConstants.CDMA_PHONE</div><div>     * and TelephonyManager.PHONE_TYPE_GSM if RILConstants.GSM_PHONE</div><div>     * @param subId user preferred subId.</div><div>     */</div><div>    int getActivePhoneTypeForSubscriber(int subId);</div><div><br/></div><div>    /**</div><div>     * Returns the CDMA ERI icon index to display</div><div>     */</div><div>    int getCdmaEriIconIndex();</div><div><br/></div><div>    /**</div><div>     * Returns the CDMA ERI icon index to display on particular subId.</div><div>     * @param subId user preferred subId.</div><div>     */</div><div>    int getCdmaEriIconIndexForSubscriber(int subId);</div><div><br/></div><div>    /**</div><div>     * Returns the CDMA ERI icon mode,</div><div>     * 0 - ON</div><div>     * 1 - FLASHING</div><div>     */</div><div>    int getCdmaEriIconMode();</div><div><br/></div><div>    /**</div><div>     * Returns the CDMA ERI icon mode on particular subId,</div><div>     * 0 - ON</div><div>     * 1 - FLASHING</div><div>     * @param subId user preferred subId.</div><div>     */</div><div>    int getCdmaEriIconModeForSubscriber(int subId);</div><div><br/></div><div>    /**</div><div>     * Returns the CDMA ERI text,</div><div>     */</div><div>    String getCdmaEriText();</div><div><br/></div><div>    /**</div><div>     * Returns the CDMA ERI text for particular subId,</div><div>     * @param subId user preferred subId.</div><div>     */</div><div>    String getCdmaEriTextForSubscriber(int subId);</div><div><br/></div><div>    /**</div><div>     * Returns true if OTA service provisioning needs to run.</div><div>     * Only relevant on some technologies, others will always</div><div>     * return false.</div><div>     */</div><div>    boolean needsOtaServiceProvisioning();</div><div><br/></div><div>    /**</div><div>     * Sets the voicemail number for a particular subscriber.</div><div>     */</div><div>    boolean setVoiceMailNumber(int subId, String alphaTag, String number);</div><div><br/></div><div>    /**</div><div>      * Returns the unread count of voicemails</div><div>      */</div><div>    int getVoiceMessageCount();</div><div><br/></div><div>    /**</div><div>     * Returns the unread count of voicemails for a subId.</div><div>     * @param subId user preferred subId.</div><div>     * Returns the unread count of voicemails</div><div>     */</div><div>    int getVoiceMessageCountForSubscriber(int subId);</div><div><br/></div><div>    /**</div><div>      * Returns the network type for data transmission</div><div>      */</div><div>    int getNetworkType();</div><div><br/></div><div>    /**</div><div>     * Returns the network type of a subId.</div><div>     * @param subId user preferred subId.</div><div>     * Returns the network type</div><div>     */</div><div>    int getNetworkTypeForSubscriber(int subId);</div><div><br/></div><div>    /**</div><div>      * Returns the network type for data transmission</div><div>      */</div><div>    int getDataNetworkType();</div><div><br/></div><div>    /**</div><div>      * Returns the data network type of a subId</div><div>      * @param subId user preferred subId.</div><div>      * Returns the network type</div><div>      */</div><div>    int getDataNetworkTypeForSubscriber(int subId);</div><div><br/></div><div>    /**</div><div>      * Returns the network type for voice</div><div>      */</div><div>    int getVoiceNetworkType();</div><div><br/></div><div>    /**</div><div>      * Returns the voice network type of a subId</div><div>      * @param subId user preferred subId.</div><div>      * Returns the network type</div><div>      */</div><div>    int getVoiceNetworkTypeForSubscriber(int subId);</div><div><br/></div><div>    /**</div><div>     * Return true if an ICC card is present</div><div>     */</div><div>    boolean hasIccCard();</div><div><br/></div><div>    /**</div><div>     * Return true if an ICC card is present for a subId.</div><div>     * @param slotId user preferred slotId.</div><div>     * Return true if an ICC card is present</div><div>     */</div><div>    boolean hasIccCardUsingSlotId(int slotId);</div><div><br/></div><div>    /**</div><div>     * Return if the current radio is LTE on CDMA. This</div><div>     * is a tri-state return value as for a period of time</div><div>     * the mode may be unknown.</div><div>     *</div><div>     * @return {@link Phone#LTE_ON_CDMA_UNKNOWN}, {@link Phone#LTE_ON_CDMA_FALSE}</div><div>     * or {@link PHone#LTE_ON_CDMA_TRUE}</div><div>     */</div><div>    int getLteOnCdmaMode();</div><div><br/></div><div>    /**</div><div>     * Return if the current radio is LTE on CDMA. This</div><div>     * is a tri-state return value as for a period of time</div><div>     * the mode may be unknown.</div><div>     *</div><div>     * @return {@link Phone#LTE_ON_CDMA_UNKNOWN}, {@link Phone#LTE_ON_CDMA_FALSE}</div><div>     * or {@link PHone#LTE_ON_CDMA_TRUE}</div><div>     */</div><div>    int getLteOnCdmaModeForSubscriber(int subId);</div><div><br/></div><div>    /**</div><div>     * Returns the all observed cell information of the device.</div><div>     */</div><div>    List&lt;CellInfo&gt; getAllCellInfo();</div><div><br/></div><div>    /**</div><div>     * Sets minimum time in milli-seconds between onCellInfoChanged</div><div>     */</div><div>    void setCellInfoListRate(int rateInMillis);</div><div><br/></div><div>    /**</div><div>     * get default sim</div><div>     * @return sim id</div><div>     */</div><div>    int getDefaultSim();</div><div><br/></div><div>    /**</div><div>     * Opens a logical channel to the ICC card.</div><div>     *</div><div>     * Input parameters equivalent to TS 27.007 AT+CCHO command.</div><div>     *</div><div>     * @param AID Application id. See ETSI 102.221 and 101.220.</div><div>     * @return an IccOpenLogicalChannelResponse object.</div><div>     */</div><div>    IccOpenLogicalChannelResponse iccOpenLogicalChannel(String AID);</div><div><br/></div><div>    /**</div><div>     * Closes a previously opened logical channel to the ICC card.</div><div>     *</div><div>     * Input parameters equivalent to TS 27.007 AT+CCHC command.</div><div>     *</div><div>     * @param channel is the channel id to be closed as retruned by a</div><div>     *            successful iccOpenLogicalChannel.</div><div>     * @return true if the channel was closed successfully.</div><div>     */</div><div>    boolean iccCloseLogicalChannel(int channel);</div><div><br/></div><div>    /**</div><div>     * Transmit an APDU to the ICC card over a logical channel.</div><div>     *</div><div>     * Input parameters equivalent to TS 27.007 AT+CGLA command.</div><div>     *</div><div>     * @param channel is the channel id to be closed as retruned by a</div><div>     *            successful iccOpenLogicalChannel.</div><div>     * @param cla Class of the APDU command.</div><div>     * @param instruction Instruction of the APDU command.</div><div>     * @param p1 P1 value of the APDU command.</div><div>     * @param p2 P2 value of the APDU command.</div><div>     * @param p3 P3 value of the APDU command. If p3 is negative a 4 byte APDU</div><div>     *            is sent to the SIM.</div><div>     * @param data Data to be sent with the APDU.</div><div>     * @return The APDU response from the ICC card with the status appended at</div><div>     *            the end. If an error occurs, an empty string is returned.</div><div>     */</div><div>    String iccTransmitApduLogicalChannel(int channel, int cla, int instruction,</div><div>            int p1, int p2, int p3, String data);</div><div><br/></div><div>    /**</div><div>     * Transmit an APDU to the ICC card over the basic channel.</div><div>     *</div><div>     * Input parameters equivalent to TS 27.007 AT+CSIM command.</div><div>     *</div><div>     * @param cla Class of the APDU command.</div><div>     * @param instruction Instruction of the APDU command.</div><div>     * @param p1 P1 value of the APDU command.</div><div>     * @param p2 P2 value of the APDU command.</div><div>     * @param p3 P3 value of the APDU command. If p3 is negative a 4 byte APDU</div><div>     *            is sent to the SIM.</div><div>     * @param data Data to be sent with the APDU.</div><div>     * @return The APDU response from the ICC card with the status appended at</div><div>     *            the end. If an error occurs, an empty string is returned.</div><div>     */</div><div>    String iccTransmitApduBasicChannel(int cla, int instruction,</div><div>            int p1, int p2, int p3, String data);</div><div><br/></div><div>    /**</div><div>     * Returns the response APDU for a command APDU sent through SIM_IO.</div><div>     *</div><div>     * @param fileID</div><div>     * @param command</div><div>     * @param p1 P1 value of the APDU command.</div><div>     * @param p2 P2 value of the APDU command.</div><div>     * @param p3 P3 value of the APDU command.</div><div>     * @param filePath</div><div>     * @return The APDU response.</div><div>     */</div><div>    byte[] iccExchangeSimIO(int fileID, int command, int p1, int p2, int p3,</div><div>            String filePath);</div><div><br/></div><div>    /**</div><div>     * Send ENVELOPE to the SIM and returns the response.</div><div>     *</div><div>     * @param contents  String containing SAT/USAT response in hexadecimal</div><div>     *                  format starting with command tag. See TS 102 223 for</div><div>     *                  details.</div><div>     * @return The APDU response from the ICC card, with the last 4 bytes</div><div>     *         being the status word. If the command fails, returns an empty</div><div>     *         string.</div><div>     */</div><div>    String sendEnvelopeWithStatus(String content);</div><div><br/></div><div>    /**</div><div>     * Read one of the NV items defined in {@link RadioNVItems} / {@code ril_nv_items.h}.</div><div>     * Used for device configuration by some CDMA operators.</div><div>     *</div><div>     * @param itemID the ID of the item to read.</div><div>     * @return the NV item as a String, or null on any failure.</div><div>     */</div><div>    String nvReadItem(int itemID);</div><div><br/></div><div>    /**</div><div>     * Write one of the NV items defined in {@link RadioNVItems} / {@code ril_nv_items.h}.</div><div>     * Used for device configuration by some CDMA operators.</div><div>     *</div><div>     * @param itemID the ID of the item to read.</div><div>     * @param itemValue the value to write, as a String.</div><div>     * @return true on success; false on any failure.</div><div>     */</div><div>    boolean nvWriteItem(int itemID, String itemValue);</div><div><br/></div><div>    /**</div><div>     * Update the CDMA Preferred Roaming List (PRL) in the radio NV storage.</div><div>     * Used for device configuration by some CDMA operators.</div><div>     *</div><div>     * @param preferredRoamingList byte array containing the new PRL.</div><div>     * @return true on success; false on any failure.</div><div>     */</div><div>    boolean nvWriteCdmaPrl(in byte[] preferredRoamingList);</div><div><br/></div><div>    /**</div><div>     * Perform the specified type of NV config reset. The radio will be taken offline</div><div>     * and the device must be rebooted after the operation. Used for device</div><div>     * configuration by some CDMA operators.</div><div>     *</div><div>     * @param resetType the type of reset to perform (1 == factory reset; 2 == NV-only reset).</div><div>     * @return true on success; false on any failure.</div><div>     */</div><div>    boolean nvResetConfig(int resetType);</div><div><br/></div><div>    /*</div><div>     * Get the calculated preferred network type.</div><div>     * Used for device configuration by some CDMA operators.</div><div>     *</div><div>     * @return the calculated preferred network type, defined in RILConstants.java.</div><div>     */</div><div>    int getCalculatedPreferredNetworkType();</div><div><br/></div><div>    /*</div><div>     * Get the preferred network type.</div><div>     * Used for device configuration by some CDMA operators.</div><div>     *</div><div>     * @return the preferred network type, defined in RILConstants.java.</div><div>     */</div><div>    int getPreferredNetworkType();</div><div><br/></div><div>    /**</div><div>     * Check TETHER_DUN_REQUIRED and TETHER_DUN_APN settings, net.tethering.noprovisioning</div><div>     * SystemProperty, and config_tether_apndata to decide whether DUN APN is required for</div><div>     * tethering.</div><div>     *</div><div>     * @return 0: Not required. 1: required. 2: Not set.</div><div>     */</div><div>    int getTetherApnRequired();</div><div><br/></div><div>    /**</div><div>     * Set the preferred network type.</div><div>     * Used for device configuration by some CDMA operators.</div><div>     *</div><div>     * @param networkType the preferred network type, defined in RILConstants.java.</div><div>     * @return true on success; false on any failure.</div><div>     */</div><div>    boolean setPreferredNetworkType(int networkType);</div><div><br/></div><div>    /**</div><div>     * User enable/disable Mobile Data.</div><div>     *</div><div>     * @param enable true to turn on, else false</div><div>     */</div><div>    void setDataEnabled(int subId, boolean enable);</div><div><br/></div><div>    /**</div><div>     * Get the user enabled state of Mobile Data.</div><div>     *</div><div>     * @return true on enabled</div><div>     */</div><div>    boolean getDataEnabled(int subId);</div><div><br/></div><div>    /**</div><div>     * Get P-CSCF address from PCO after data connection is established or modified.</div><div>     * @param apnType the apnType, &quot;ims&quot; for IMS APN, &quot;emergency&quot; for EMERGENCY APN</div><div>     */</div><div>    String[] getPcscfAddress(String apnType);</div><div><br/></div><div>    /**</div><div>     * Set IMS registration state</div><div>     */</div><div>    void setImsRegistrationState(boolean registered);</div><div><br/></div><div>    /**</div><div>     * Return MDN string for CDMA phone.</div><div>     * @param subId user preferred subId.</div><div>     */</div><div>    String getCdmaMdn(int subId);</div><div><br/></div><div>    /**</div><div>     * Return MIN string for CDMA phone.</div><div>     * @param subId user preferred subId.</div><div>     */</div><div>    String getCdmaMin(int subId);</div><div><br/></div><div>    /**</div><div>     * Has the calling application been granted special privileges by the carrier.</div><div>     *</div><div>     * If any of the packages in the calling UID has carrier privileges, the</div><div>     * call will return true. This access is granted by the owner of the UICC</div><div>     * card and does not depend on the registered carrier.</div><div>     *</div><div>     * TODO: Add a link to documentation.</div><div>     *</div><div>     * @return carrier privilege status defined in TelephonyManager.</div><div>     */</div><div>    int getCarrierPrivilegeStatus();</div><div><br/></div><div>    /**</div><div>     * Similar to above, but check for pkg whose name is pkgname.</div><div>     */</div><div>    int checkCarrierPrivilegesForPackage(String pkgname);</div><div><br/></div><div>    /**</div><div>     * Returns the package name of the carrier apps that should handle the input intent.</div><div>     *</div><div>     * @param packageManager PackageManager for getting receivers.</div><div>     * @param intent Intent that will be sent.</div><div>     * @return list of carrier app package names that can handle the intent.</div><div>     *         Returns null if there is an error and an empty list if there</div><div>     *         are no matching packages.</div><div>     */</div><div>    List&lt;String&gt; getCarrierPackageNamesForIntent(in Intent intent);</div><div><br/></div><div>    /**</div><div>     * Set the line 1 phone number string and its alphatag for the current ICCID</div><div>     * for display purpose only, for example, displayed in Phone Status. It won't</div><div>     * change the actual MSISDN/MDN. To unset alphatag or number, pass in a null</div><div>     * value.</div><div>     *</div><div>     * @param subId the subscriber that the alphatag and dialing number belongs to.</div><div>     * @param alphaTag alpha-tagging of the dailing nubmer</div><div>     * @param number The dialing number</div><div>     * @return true if the operation was executed correctly.</div><div>     */</div><div>    boolean setLine1NumberForDisplayForSubscriber(int subId, String alphaTag, String number);</div><div><br/></div><div>    /**</div><div>     * Returns the displayed dialing number string if it was set previously via</div><div>     * {@link #setLine1NumberForDisplay}. Otherwise returns null.</div><div>     *</div><div>     * @param subId whose dialing number for line 1 is returned.</div><div>     * @return the displayed dialing number if set, or null if not set.</div><div>     */</div><div>    String getLine1NumberForDisplay(int subId);</div><div><br/></div><div>    /**</div><div>     * Returns the displayed alphatag of the dialing number if it was set</div><div>     * previously via {@link #setLine1NumberForDisplay}. Otherwise returns null.</div><div>     *</div><div>     * @param subId whose alphatag associated with line 1 is returned.</div><div>     * @return the displayed alphatag of the dialing number if set, or null if</div><div>     *         not set.</div><div>     */</div><div>    String getLine1AlphaTagForDisplay(int subId);</div><div><br/></div><div>    String[] getMergedSubscriberIds();</div><div><br/></div><div>    /**</div><div>     * Override the operator branding for the current ICCID.</div><div>     *</div><div>     * Once set, whenever the SIM is present in the device, the service</div><div>     * provider name (SPN) and the operator name will both be replaced by the</div><div>     * brand value input. To unset the value, the same function should be</div><div>     * called with a null brand value.</div><div>     *</div><div>     * &lt;p&gt;Requires Permission:</div><div>     *   {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE}</div><div>     *  or has to be carrier app - see #hasCarrierPrivileges.</div><div>     *</div><div>     * @param brand The brand name to display/set.</div><div>     * @return true if the operation was executed correctly.</div><div>     */</div><div>    boolean setOperatorBrandOverride(String brand);</div><div><br/></div><div>    /**</div><div>     * Override the roaming indicator for the current ICCID.</div><div>     *</div><div>     * Using this call, the carrier app (see #hasCarrierPrivileges) can override</div><div>     * the platform's notion of a network operator being considered roaming or not.</div><div>     * The change only affects the ICCID that was active when this call was made.</div><div>     *</div><div>     * If null is passed as any of the input, the corresponding value is deleted.</div><div>     *</div><div>     * &lt;p&gt;Requires that the caller have carrier privilege. See #hasCarrierPrivileges.</div><div>     *</div><div>     * @param gsmRoamingList - List of MCCMNCs to be considered roaming for 3GPP RATs.</div><div>     * @param gsmNonRoamingList - List of MCCMNCs to be considered not roaming for 3GPP RATs.</div><div>     * @param cdmaRoamingList - List of SIDs to be considered roaming for 3GPP2 RATs.</div><div>     * @param cdmaNonRoamingList - List of SIDs to be considered not roaming for 3GPP2 RATs.</div><div>     * @return true if the operation was executed correctly.</div><div>     */</div><div>    boolean setRoamingOverride(in List&lt;String&gt; gsmRoamingList,</div><div>            in List&lt;String&gt; gsmNonRoamingList, in List&lt;String&gt; cdmaRoamingList,</div><div>            in List&lt;String&gt; cdmaNonRoamingList);</div><div><br/></div><div>    /**</div><div>     * Returns the result and response from RIL for oem request</div><div>     *</div><div>     * @param oemReq the data is sent to ril.</div><div>     * @param oemResp the respose data from RIL.</div><div>     * @return negative value request was not handled or get error</div><div>     *         0 request was handled succesfully, but no response data</div><div>     *         positive value success, data length of response</div><div>     */</div><div>    int invokeOemRilRequestRaw(in byte[] oemReq, out byte[] oemResp);</div><div><br/></div><div>    /**</div><div>     * Check if any mobile Radios need to be shutdown.</div><div>     *</div><div>     * @return true is any mobile radio needs to be shutdown</div><div>     */</div><div>    boolean needMobileRadioShutdown();</div><div><br/></div><div>    /**</div><div>     * Shutdown Mobile Radios</div><div>     */</div><div>    void shutdownMobileRadios();</div><div><br/></div><div>    /**</div><div>     * Set phone radio type and access technology.</div><div>     *</div><div>     * @param rafs an RadioAccessFamily array to indicate all phone's</div><div>     *        new radio access family. The length of RadioAccessFamily</div><div>     *        must equ]]al to phone count.</div><div>     */</div><div>    void setRadioCapability(in RadioAccessFamily[] rafs);</div><div><br/></div><div>    /**</div><div>     * Get phone radio type and access technology.</div><div>     *</div><div>     * @param phoneId which phone you want to get</div><div>     * @return phone radio type and access technology</div><div>     */</div><div>    int getRadioAccessFamily(in int phoneId);</div><div><br/></div><div>    /**</div><div>     * Enables or disables video calling.</div><div>     *</div><div>     * @param enable Whether to enable video calling.</div><div>     */</div><div>    void enableVideoCalling(boolean enable);</div><div><br/></div><div>    /**</div><div>     * Whether video calling has been enabled by the user.</div><div>     *</div><div>     * @return {@code True} if the user has enabled video calling, {@code false} otherwise.</div><div>     */</div><div>    boolean isVideoCallingEnabled();</div><div><br/></div><div>    /**</div><div>     * Get IMS Registration Status</div><div>     */</div><div>    boolean isImsRegistered();</div><div><br/></div><div>    /**</div><div>      * Returns the unique device ID of phone, for example, the IMEI for</div><div>      * GSM and the MEID for CDMA phones. Return null if device ID is not available.</div><div>      *</div><div>      * &lt;p&gt;Requires Permission:</div><div>      *   {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}</div><div>      */</div><div>    String getDeviceId();</div><div><br/></div><div><br/></div><div>    String getIccAtr(int slotId);</div><div>    byte[] iccOpenLogicalChannelWithSW(int slotId, String AID);</div><div>    byte[] iccExchangeSimIOUsingSlot(int slotId, int fileID, int command, int p1, int p2, int p3,</div><div>            String filePath);</div><div>    byte[] iccExchangeSimIOExUsingSlot(int slotId, int fileID, int command,</div><div>                                     int p1, int p2, int p3, String filePath, String data, String pin2);</div><div><br/></div><div><br/></div><div>    /**</div><div>     * Opens a logical channel to the ICC card.</div><div>     *</div><div>     * Input parameters equivalent to TS 27.007 AT+CCHO command.</div><div>     *</div><div>     * @param AID Application id. See ETSI 102.221 and 101.220.</div><div>     * @return an IccOpenLogicalChannelResponse object.</div><div>     */</div><div>    IccOpenLogicalChannelResponse iccOpenLogicalChannelUsingSlot(int slotId, String AID);</div><div><br/></div><div>    /**</div><div>     * Closes a previously opened logical channel to the ICC card.</div><div>     *</div><div>     * Input parameters equivalent to TS 27.007 AT+CCHC command.</div><div>     *</div><div>     * @param channel is the channel id to be closed as retruned by a</div><div>     *            successful iccOpenLogicalChannel.</div><div>     * @return true if the channel was closed successfully.</div><div>     */</div><div>    boolean iccCloseLogicalChannelUsingSlot(int slotId, int channel);</div><div><br/></div><div>    /**</div><div>     * Transmit an APDU to the ICC card over a logical channel.</div><div>     *</div><div>     * Input parameters equivalent to TS 27.007 AT+CGLA command.</div><div>     *</div><div>     * @param channel is the channel id to be closed as retruned by a</div><div>     *            successful iccOpenLogicalChannel.</div><div>     * @param cla Class of the APDU command.</div><div>     * @param instruction Instruction of the APDU command.</div><div>     * @param p1 P1 value of the APDU command.</div><div>     * @param p2 P2 value of the APDU command.</div><div>     * @param p3 P3 value of the APDU command. If p3 is negative a 4 byte APDU</div><div>     *            is sent to the SIM.</div><div>     * @param data Data to be sent with the APDU.</div><div>     * @return The APDU response from the ICC card with the status appended at</div><div>     *            the end. If an error occurs, an empty string is returned.</div><div>     */</div><div>    String iccTransmitApduLogicalChannelUsingSlot(int slotId, int channel, int cla, int instruction,</div><div>            int p1, int p2, int p3, String data);</div><div><br/></div><div>    String iccTransmitApduBasicChannelUsingSlot(int slotId, int cla, int command, int p1, int p2,</div><div>                int p3, String data);</div><div><br/></div><div>    void setPolicyDataEnableForSubscriber(int subId, boolean enabled);</div><div><br/></div><div>}</div><div><br/></div></span>
</div></body></html> 