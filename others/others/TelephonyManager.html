<html>
<head>
  <title>TelephonyManager</title>
  <basefont face="Microsoft YaHei" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/301769 (zh-CN); Windows/6.3.9600 (Win64);"/>
  <style>
    body, td {
      font-family: Microsoft YaHei;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1002"/>
<h1>TelephonyManager</h1>

<div>
<span><div>/*</div><div>* Copyright (C) 2014 MediaTek Inc.</div><div>* Modification based on code covered by the mentioned copyright</div><div>* and/or permission notice(s).</div><div>*/</div><div>/*</div><div> * Copyright (C) 2008 The Android Open Source Project</div><div> *</div><div> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</div><div> * you may not use this file except in compliance with the License.</div><div> * You may obtain a copy of the License at</div><div> *</div><div> *      http://www.apache.org/licenses/LICENSE-2.0</div><div> *</div><div> * Unless required by applicable law or agreed to in writing, software</div><div> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</div><div> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</div><div> * See the License for the specific language governing permissions and</div><div> * limitations under the License.</div><div> */</div><div><br/></div><div>package android.telephony;</div><div><br/></div><div>import android.annotation.Nullable;</div><div>import android.annotation.SystemApi;</div><div>import android.annotation.SdkConstant;</div><div>import android.annotation.SdkConstant.SdkConstantType;</div><div>import android.content.ContentResolver;</div><div>import android.content.Context;</div><div>import android.content.Intent;</div><div>import android.provider.Settings;</div><div>import android.provider.Settings.SettingNotFoundException;</div><div>import android.os.Bundle;</div><div>import android.os.RemoteException;</div><div>import android.os.ServiceManager;</div><div>import android.os.SystemProperties;</div><div>import android.util.Log;</div><div><br/></div><div>import com.android.internal.telecom.ITelecomService;</div><div>import com.android.internal.telephony.IPhoneSubInfo;</div><div>import com.android.internal.telephony.ITelephony;</div><div>import com.android.internal.telephony.ITelephonyRegistry;</div><div>import com.android.internal.telephony.PhoneConstants;</div><div>import com.android.internal.telephony.RILConstants;</div><div>import com.android.internal.telephony.TelephonyProperties;</div><div><br/></div><div>import java.io.FileInputStream;</div><div>import java.io.IOException;</div><div>import java.util.Arrays;</div><div>import java.util.List;</div><div>import java.util.Set;</div><div>import java.util.regex.Matcher;</div><div>import java.util.regex.Pattern;</div><div><br/></div><div>import com.mediatek.common.telephony.IOnlyOwnerSimSupport;</div><div>import com.mediatek.common.MPlugin;</div><div><br/></div><div>/**</div><div> * Provides access to information about the telephony services on</div><div> * the device. Applications can use the methods in this class to</div><div> * determine telephony services and states, as well as to access some</div><div> * types of subscriber information. Applications can also register</div><div> * a listener to receive notification of telephony state changes.</div><div> * &lt;p&gt;</div><div> * You do not instantiate this class directly; instead, you retrieve</div><div> * a reference to an instance through</div><div> * {@link android.content.Context#getSystemService</div><div> * Context.getSystemService(Context.TELEPHONY_SERVICE)}.</div><div> * &lt;p&gt;</div><div> * Note that access to some telephony information is</div><div> * permission-protected. Your application cannot access the protected</div><div> * information unless it has the appropriate permissions declared in</div><div> * its manifest file. Where permissions apply, they are noted in the</div><div> * the methods through which you access the protected information.</div><div> */</div><div>public class TelephonyManager {</div><div>    private static final String TAG = &quot;TelephonyManager&quot;;</div><div><br/></div><div>    private static ITelephonyRegistry sRegistry;</div><div><br/></div><div>    /**</div><div>     * The allowed states of Wi-Fi calling.</div><div>     *</div><div>     * @hide</div><div>     */</div><div>    public interface WifiCallingChoices {</div><div>        /** Always use Wi-Fi calling */</div><div>        static final int ALWAYS_USE = 0;</div><div>        /** Ask the user whether to use Wi-Fi on every call */</div><div>        static final int ASK_EVERY_TIME = 1;</div><div>        /** Never use Wi-Fi calling */</div><div>        static final int NEVER_USE = 2;</div><div>    }</div><div><br/></div><div>    private final Context mContext;</div><div>    private SubscriptionManager mSubscriptionManager;</div><div><br/></div><div>    private static String multiSimConfig =</div><div>            SystemProperties.get(TelephonyProperties.PROPERTY_MULTI_SIM_CONFIG);</div><div><br/></div><div>    /** Enum indicating multisim variants</div><div>     *  DSDS - Dual SIM Dual Standby</div><div>     *  DSDA - Dual SIM Dual Active</div><div>     *  TSTS - Triple SIM Triple Standby</div><div>     **/</div><div>    /** @hide */</div><div>    public enum MultiSimVariants {</div><div>        DSDS,</div><div>        DSDA,</div><div>        TSTS,</div><div>        UNKNOWN</div><div>    };</div><div><br/></div><div>    /** @hide */</div><div>    public TelephonyManager(Context context) {</div><div>        Context appContext = context.getApplicationContext();</div><div>        if (appContext != null) {</div><div>            mContext = appContext;</div><div>        } else {</div><div>            mContext = context;</div><div>        }</div><div>        mSubscriptionManager = SubscriptionManager.from(mContext);</div><div><br/></div><div>        try {</div><div>            mOnlyOwnerSimSupport = MPlugin.createInstance(IOnlyOwnerSimSupport.class.getName(), mContext);</div><div>        } catch (Exception e) {</div><div>            Rlog.e(TAG, &quot;Fail to create plug-in&quot;);</div><div>            e.printStackTrace();</div><div>        }</div><div><br/></div><div>        if (sRegistry == null) {</div><div>            sRegistry = ITelephonyRegistry.Stub.asInterface(ServiceManager.getService(</div><div>                    &quot;telephony.registry&quot;));</div><div>        }</div><div>    }</div><div><br/></div><div>    /** @hide */</div><div>    private TelephonyManager() {</div><div>        mContext = null;</div><div><br/></div><div>        try {</div><div>            mOnlyOwnerSimSupport = MPlugin.createInstance(IOnlyOwnerSimSupport.class.getName());</div><div>        } catch (Exception e) {</div><div>            Rlog.e(TAG, &quot;Fail to create plug-in&quot;);</div><div>            e.printStackTrace();</div><div>        }</div><div>    }</div><div><br/></div><div>    private static TelephonyManager sInstance = new TelephonyManager();</div><div><br/></div><div>    /** @hide</div><div>    /* @deprecated - use getSystemService as described above */</div><div>    public static TelephonyManager getDefault() {</div><div>        return sInstance;</div><div>    }</div><div><br/></div><div><br/></div><div>    /**</div><div>     * Returns the multi SIM variant</div><div>     * Returns DSDS for Dual SIM Dual Standby</div><div>     * Returns DSDA for Dual SIM Dual Active</div><div>     * Returns TSTS for Triple SIM Triple Standby</div><div>     * Returns UNKNOWN for others</div><div>     */</div><div>    /** {@hide} */</div><div>    public MultiSimVariants getMultiSimConfiguration() {</div><div>        String mSimConfig =</div><div>            SystemProperties.get(TelephonyProperties.PROPERTY_MULTI_SIM_CONFIG);</div><div>        if (mSimConfig.equals(&quot;dsds&quot;)) {</div><div>            return MultiSimVariants.DSDS;</div><div>        } else if (mSimConfig.equals(&quot;dsda&quot;)) {</div><div>            return MultiSimVariants.DSDA;</div><div>        } else if (mSimConfig.equals(&quot;tsts&quot;)) {</div><div>            return MultiSimVariants.TSTS;</div><div>        } else {</div><div>            return MultiSimVariants.UNKNOWN;</div><div>        }</div><div>    }</div><div><br/></div><div><br/></div><div>    /**</div><div>     * Returns the number of phones available.</div><div>     * Returns 1 for Single standby mode (Single SIM functionality)</div><div>     * Returns 2 for Dual standby mode.(Dual SIM functionality)</div><div>     */</div><div>    /** {@hide} */</div><div>    public int getPhoneCount() {</div><div>        int phoneCount = 1;</div><div>        switch (getMultiSimConfiguration()) {</div><div>            case UNKNOWN:</div><div>                phoneCount = 1;</div><div>                break;</div><div>            case DSDS:</div><div>            case DSDA:</div><div>                phoneCount = PhoneConstants.MAX_PHONE_COUNT_DUAL_SIM;</div><div>                break;</div><div>            case TSTS:</div><div>                phoneCount = PhoneConstants.MAX_PHONE_COUNT_TRI_SIM;</div><div>                break;</div><div>        }</div><div>        return phoneCount;</div><div>    }</div><div><br/></div><div>    /** {@hide} */</div><div>    public static TelephonyManager from(Context context) {</div><div>        return (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);</div><div>    }</div><div><br/></div><div>    /** {@hide} */</div><div>    public boolean isMultiSimEnabled() {</div><div>        return (multiSimConfig.equals(&quot;dsds&quot;) || multiSimConfig.equals(&quot;dsda&quot;) ||</div><div>            multiSimConfig.equals(&quot;tsts&quot;));</div><div>    }</div><div><br/></div><div>    //</div><div>    // Broadcast Intent actions</div><div>    //</div><div><br/></div><div>    /**</div><div>     * Broadcast intent action indicating that the call state (cellular)</div><div>     * on the device has changed.</div><div>     *</div><div>     * &lt;p&gt;</div><div>     * The {@link #EXTRA_STATE} extra indicates the new call state.</div><div>     * If the new state is RINGING, a second extra</div><div>     * {@link #EXTRA_INCOMING_NUMBER} provides the incoming phone number as</div><div>     * a String.</div><div>     *</div><div>     * &lt;p class=&quot;note&quot;&gt;</div><div>     * Requires the READ_PHONE_STATE permission.</div><div>     *</div><div>     * &lt;p class=&quot;note&quot;&gt;</div><div>     * This was a {@link android.content.Context#sendStickyBroadcast sticky}</div><div>     * broadcast in version 1.0, but it is no longer sticky.</div><div>     * Instead, use {@link #getCallState} to synchronously query the current call state.</div><div>     *</div><div>     * @see #EXTRA_STATE</div><div>     * @see #EXTRA_INCOMING_NUMBER</div><div>     * @see #getCallState</div><div>     */</div><div>    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)</div><div>    public static final String ACTION_PHONE_STATE_CHANGED =</div><div>            &quot;android.intent.action.PHONE_STATE&quot;;</div><div><br/></div><div>    /**</div><div>     * The Phone app sends this intent when a user opts to respond-via-message during an incoming</div><div>     * call. By default, the device's default SMS app consumes this message and sends a text message</div><div>     * to the caller. A third party app can also provide this functionality by consuming this Intent</div><div>     * with a {@link android.app.Service} and sending the message using its own messaging system.</div><div>     * &lt;p&gt;The intent contains a URI (available from {@link android.content.Intent#getData})</div><div>     * describing the recipient, using either the {@code sms:}, {@code smsto:}, {@code mms:},</div><div>     * or {@code mmsto:} URI schema. Each of these URI schema carry the recipient information the</div><div>     * same way: the path part of the URI contains the recipient's phone number or a comma-separated</div><div>     * set of phone numbers if there are multiple recipients. For example, {@code</div><div>     * smsto:2065551234}.&lt;/p&gt;</div><div>     *</div><div>     * &lt;p&gt;The intent may also contain extras for the message text (in {@link</div><div>     * android.content.Intent#EXTRA_TEXT}) and a message subject</div><div>     * (in {@link android.content.Intent#EXTRA_SUBJECT}).&lt;/p&gt;</div><div>     *</div><div>     * &lt;p class=&quot;note&quot;&gt;&lt;strong&gt;Note:&lt;/strong&gt;</div><div>     * The intent-filter that consumes this Intent needs to be in a {@link android.app.Service}</div><div>     * that requires the</div><div>     * permission {@link android.Manifest.permission#SEND_RESPOND_VIA_MESSAGE}.&lt;/p&gt;</div><div>     * &lt;p&gt;For example, the service that receives this intent can be declared in the manifest file</div><div>     * with an intent filter like this:&lt;/p&gt;</div><div>     * &lt;pre&gt;</div><div>     * &amp;lt;!-- Service that delivers SMS messages received from the phone &quot;quick response&quot; --&gt;</div><div>     * &amp;lt;service android:name=&quot;.HeadlessSmsSendService&quot;</div><div>     *          android:permission=&quot;android.permission.SEND_RESPOND_VIA_MESSAGE&quot;</div><div>     *          android:exported=&quot;true&quot; &gt;</div><div>     *   &amp;lt;intent-filter&gt;</div><div>     *     &amp;lt;action android:name=&quot;android.intent.action.RESPOND_VIA_MESSAGE&quot; /&gt;</div><div>     *     &amp;lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;</div><div>     *     &amp;lt;data android:scheme=&quot;sms&quot; /&gt;</div><div>     *     &amp;lt;data android:scheme=&quot;smsto&quot; /&gt;</div><div>     *     &amp;lt;data android:scheme=&quot;mms&quot; /&gt;</div><div>     *     &amp;lt;data android:scheme=&quot;mmsto&quot; /&gt;</div><div>     *   &amp;lt;/intent-filter&gt;</div><div>     * &amp;lt;/service&gt;&lt;/pre&gt;</div><div>     * &lt;p&gt;</div><div>     * Output: nothing.</div><div>     */</div><div>    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)</div><div>    public static final String ACTION_RESPOND_VIA_MESSAGE =</div><div>            &quot;android.intent.action.RESPOND_VIA_MESSAGE&quot;;</div><div><br/></div><div>    /**</div><div>     * The lookup key used with the {@link #ACTION_PHONE_STATE_CHANGED} broadcast</div><div>     * for a String containing the new call state.</div><div>     *</div><div>     * @see #EXTRA_STATE_IDLE</div><div>     * @see #EXTRA_STATE_RINGING</div><div>     * @see #EXTRA_STATE_OFFHOOK</div><div>     *</div><div>     * &lt;p class=&quot;note&quot;&gt;</div><div>     * Retrieve with</div><div>     * {@link android.content.Intent#getStringExtra(String)}.</div><div>     */</div><div>    public static final String EXTRA_STATE = PhoneConstants.STATE_KEY;</div><div><br/></div><div>    /**</div><div>     * Value used with {@link #EXTRA_STATE} corresponding to</div><div>     * {@link #CALL_STATE_IDLE}.</div><div>     */</div><div>    public static final String EXTRA_STATE_IDLE = PhoneConstants.State.IDLE.toString();</div><div><br/></div><div>    /**</div><div>     * Value used with {@link #EXTRA_STATE} corresponding to</div><div>     * {@link #CALL_STATE_RINGING}.</div><div>     */</div><div>    public static final String EXTRA_STATE_RINGING = PhoneConstants.State.RINGING.toString();</div><div><br/></div><div>    /**</div><div>     * Value used with {@link #EXTRA_STATE} corresponding to</div><div>     * {@link #CALL_STATE_OFFHOOK}.</div><div>     */</div><div>    public static final String EXTRA_STATE_OFFHOOK = PhoneConstants.State.OFFHOOK.toString();</div><div><br/></div><div>    /**</div><div>     * The lookup key used with the {@link #ACTION_PHONE_STATE_CHANGED} broadcast</div><div>     * for a String containing the incoming phone number.</div><div>     * Only valid when the new call state is RINGING.</div><div>     *</div><div>     * &lt;p class=&quot;note&quot;&gt;</div><div>     * Retrieve with</div><div>     * {@link android.content.Intent#getStringExtra(String)}.</div><div>     */</div><div>    public static final String EXTRA_INCOMING_NUMBER = &quot;incoming_number&quot;;</div><div><br/></div><div>    /**</div><div>     * Broadcast intent action indicating that a precise call state</div><div>     * (cellular) on the device has changed.</div><div>     *</div><div>     * &lt;p&gt;</div><div>     * The {@link #EXTRA_RINGING_CALL_STATE} extra indicates the ringing call state.</div><div>     * The {@link #EXTRA_FOREGROUND_CALL_STATE} extra indicates the foreground call state.</div><div>     * The {@link #EXTRA_BACKGROUND_CALL_STATE} extra indicates the background call state.</div><div>     * The {@link #EXTRA_DISCONNECT_CAUSE} extra indicates the disconnect cause.</div><div>     * The {@link #EXTRA_PRECISE_DISCONNECT_CAUSE} extra indicates the precise disconnect cause.</div><div>     *</div><div>     * &lt;p class=&quot;note&quot;&gt;</div><div>     * Requires the READ_PRECISE_PHONE_STATE permission.</div><div>     *</div><div>     * @see #EXTRA_RINGING_CALL_STATE</div><div>     * @see #EXTRA_FOREGROUND_CALL_STATE</div><div>     * @see #EXTRA_BACKGROUND_CALL_STATE</div><div>     * @see #EXTRA_DISCONNECT_CAUSE</div><div>     * @see #EXTRA_PRECISE_DISCONNECT_CAUSE</div><div>     *</div><div>     * &lt;p class=&quot;note&quot;&gt;</div><div>     * Requires the READ_PRECISE_PHONE_STATE permission.</div><div>     *</div><div>     * @hide</div><div>     */</div><div>    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)</div><div>    public static final String ACTION_PRECISE_CALL_STATE_CHANGED =</div><div>            &quot;android.intent.action.PRECISE_CALL_STATE&quot;;</div><div><br/></div><div>    /**</div><div>     * The lookup key used with the {@link #ACTION_PRECISE_CALL_STATE_CHANGED} broadcast</div><div>     * for an integer containing the state of the current ringing call.</div><div>     *</div><div>     * @see PreciseCallState#PRECISE_CALL_STATE_NOT_VALID</div><div>     * @see PreciseCallState#PRECISE_CALL_STATE_IDLE</div><div>     * @see PreciseCallState#PRECISE_CALL_STATE_ACTIVE</div><div>     * @see PreciseCallState#PRECISE_CALL_STATE_HOLDING</div><div>     * @see PreciseCallState#PRECISE_CALL_STATE_DIALING</div><div>     * @see PreciseCallState#PRECISE_CALL_STATE_ALERTING</div><div>     * @see PreciseCallState#PRECISE_CALL_STATE_INCOMING</div><div>     * @see PreciseCallState#PRECISE_CALL_STATE_WAITING</div><div>     * @see PreciseCallState#PRECISE_CALL_STATE_DISCONNECTED</div><div>     * @see PreciseCallState#PRECISE_CALL_STATE_DISCONNECTING</div><div>     *</div><div>     * &lt;p class=&quot;note&quot;&gt;</div><div>     * Retrieve with</div><div>     * {@link android.content.Intent#getIntExtra(String name, int defaultValue)}.</div><div>     *</div><div>     * @hide</div><div>     */</div><div>    public static final String EXTRA_RINGING_CALL_STATE = &quot;ringing_state&quot;;</div><div><br/></div><div>    /**</div><div>     * The lookup key used with the {@link #ACTION_PRECISE_CALL_STATE_CHANGED} broadcast</div><div>     * for an integer containing the state of the current foreground call.</div><div>     *</div><div>     * @see PreciseCallState#PRECISE_CALL_STATE_NOT_VALID</div><div>     * @see PreciseCallState#PRECISE_CALL_STATE_IDLE</div><div>     * @see PreciseCallState#PRECISE_CALL_STATE_ACTIVE</div><div>     * @see PreciseCallState#PRECISE_CALL_STATE_HOLDING</div><div>     * @see PreciseCallState#PRECISE_CALL_STATE_DIALING</div><div>     * @see PreciseCallState#PRECISE_CALL_STATE_ALERTING</div><div>     * @see PreciseCallState#PRECISE_CALL_STATE_INCOMING</div><div>     * @see PreciseCallState#PRECISE_CALL_STATE_WAITING</div><div>     * @see PreciseCallState#PRECISE_CALL_STATE_DISCONNECTED</div><div>     * @see PreciseCallState#PRECISE_CALL_STATE_DISCONNECTING</div><div>     *</div><div>     * &lt;p class=&quot;note&quot;&gt;</div><div>     * Retrieve with</div><div>     * {@link android.content.Intent#getIntExtra(String name, int defaultValue)}.</div><div>     *</div><div>     * @hide</div><div>     */</div><div>    public static final String EXTRA_FOREGROUND_CALL_STATE = &quot;foreground_state&quot;;</div><div><br/></div><div>    /**</div><div>     * The lookup key used with the {@link #ACTION_PRECISE_CALL_STATE_CHANGED} broadcast</div><div>     * for an integer containing the state of the current background call.</div><div>     *</div><div>     * @see PreciseCallState#PRECISE_CALL_STATE_NOT_VALID</div><div>     * @see PreciseCallState#PRECISE_CALL_STATE_IDLE</div><div>     * @see PreciseCallState#PRECISE_CALL_STATE_ACTIVE</div><div>     * @see PreciseCallState#PRECISE_CALL_STATE_HOLDING</div><div>     * @see PreciseCallState#PRECISE_CALL_STATE_DIALING</div><div>     * @see PreciseCallState#PRECISE_CALL_STATE_ALERTING</div><div>     * @see PreciseCallState#PRECISE_CALL_STATE_INCOMING</div><div>     * @see PreciseCallState#PRECISE_CALL_STATE_WAITING</div><div>     * @see PreciseCallState#PRECISE_CALL_STATE_DISCONNECTED</div><div>     * @see PreciseCallState#PRECISE_CALL_STATE_DISCONNECTING</div><div>     *</div><div>     * &lt;p class=&quot;note&quot;&gt;</div><div>     * Retrieve with</div><div>     * {@link android.content.Intent#getIntExtra(String name, int defaultValue)}.</div><div>     *</div><div>     * @hide</div><div>     */</div><div>    public static final String EXTRA_BACKGROUND_CALL_STATE = &quot;background_state&quot;;</div><div><br/></div><div>    /**</div><div>     * The lookup key used with the {@link #ACTION_PRECISE_CALL_STATE_CHANGED} broadcast</div><div>     * for an integer containing the disconnect cause.</div><div>     *</div><div>     * @see DisconnectCause</div><div>     *</div><div>     * &lt;p class=&quot;note&quot;&gt;</div><div>     * Retrieve with</div><div>     * {@link android.content.Intent#getIntExtra(String name, int defaultValue)}.</div><div>     *</div><div>     * @hide</div><div>     */</div><div>    public static final String EXTRA_DISCONNECT_CAUSE = &quot;disconnect_cause&quot;;</div><div><br/></div><div>    /**</div><div>     * The lookup key used with the {@link #ACTION_PRECISE_CALL_STATE_CHANGED} broadcast</div><div>     * for an integer containing the disconnect cause provided by the RIL.</div><div>     *</div><div>     * @see PreciseDisconnectCause</div><div>     *</div><div>     * &lt;p class=&quot;note&quot;&gt;</div><div>     * Retrieve with</div><div>     * {@link android.content.Intent#getIntExtra(String name, int defaultValue)}.</div><div>     *</div><div>     * @hide</div><div>     */</div><div>    public static final String EXTRA_PRECISE_DISCONNECT_CAUSE = &quot;precise_disconnect_cause&quot;;</div><div><br/></div><div>    /**</div><div>     * Broadcast intent action indicating a data connection has changed,</div><div>     * providing precise information about the connection.</div><div>     *</div><div>     * &lt;p&gt;</div><div>     * The {@link #EXTRA_DATA_STATE} extra indicates the connection state.</div><div>     * The {@link #EXTRA_DATA_NETWORK_TYPE} extra indicates the connection network type.</div><div>     * The {@link #EXTRA_DATA_APN_TYPE} extra indicates the APN type.</div><div>     * The {@link #EXTRA_DATA_APN} extra indicates the APN.</div><div>     * The {@link #EXTRA_DATA_CHANGE_REASON} extra indicates the connection change reason.</div><div>     * The {@link #EXTRA_DATA_IFACE_PROPERTIES} extra indicates the connection interface.</div><div>     * The {@link #EXTRA_DATA_FAILURE_CAUSE} extra indicates the connection fail cause.</div><div>     *</div><div>     * &lt;p class=&quot;note&quot;&gt;</div><div>     * Requires the READ_PRECISE_PHONE_STATE permission.</div><div>     *</div><div>     * @see #EXTRA_DATA_STATE</div><div>     * @see #EXTRA_DATA_NETWORK_TYPE</div><div>     * @see #EXTRA_DATA_APN_TYPE</div><div>     * @see #EXTRA_DATA_APN</div><div>     * @see #EXTRA_DATA_CHANGE_REASON</div><div>     * @see #EXTRA_DATA_IFACE</div><div>     * @see #EXTRA_DATA_FAILURE_CAUSE</div><div>     * @hide</div><div>     */</div><div>    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)</div><div>    public static final String ACTION_PRECISE_DATA_CONNECTION_STATE_CHANGED =</div><div>            &quot;android.intent.action.PRECISE_DATA_CONNECTION_STATE_CHANGED&quot;;</div><div><br/></div><div>    /**</div><div>     * The lookup key used with the {@link #ACTION_PRECISE_DATA_CONNECTION_STATE_CHANGED} broadcast</div><div>     * for an integer containing the state of the current data connection.</div><div>     *</div><div>     * @see TelephonyManager#DATA_UNKNOWN</div><div>     * @see TelephonyManager#DATA_DISCONNECTED</div><div>     * @see TelephonyManager#DATA_CONNECTING</div><div>     * @see TelephonyManager#DATA_CONNECTED</div><div>     * @see TelephonyManager#DATA_SUSPENDED</div><div>     *</div><div>     * &lt;p class=&quot;note&quot;&gt;</div><div>     * Retrieve with</div><div>     * {@link android.content.Intent#getIntExtra(String name, int defaultValue)}.</div><div>     *</div><div>     * @hide</div><div>     */</div><div>    public static final String EXTRA_DATA_STATE = PhoneConstants.STATE_KEY;</div><div><br/></div><div>    /**</div><div>     * The lookup key used with the {@link #ACTION_PRECISE_DATA_CONNECTION_STATE_CHANGED} broadcast</div><div>     * for an integer containing the network type.</div><div>     *</div><div>     * @see TelephonyManager#NETWORK_TYPE_UNKNOWN</div><div>     * @see TelephonyManager#NETWORK_TYPE_GPRS</div><div>     * @see TelephonyManager#NETWORK_TYPE_EDGE</div><div>     * @see TelephonyManager#NETWORK_TYPE_UMTS</div><div>     * @see TelephonyManager#NETWORK_TYPE_CDMA</div><div>     * @see TelephonyManager#NETWORK_TYPE_EVDO_0</div><div>     * @see TelephonyManager#NETWORK_TYPE_EVDO_A</div><div>     * @see TelephonyManager#NETWORK_TYPE_1xRTT</div><div>     * @see TelephonyManager#NETWORK_TYPE_HSDPA</div><div>     * @see TelephonyManager#NETWORK_TYPE_HSUPA</div><div>     * @see TelephonyManager#NETWORK_TYPE_HSPA</div><div>     * @see TelephonyManager#NETWORK_TYPE_IDEN</div><div>     * @see TelephonyManager#NETWORK_TYPE_EVDO_B</div><div>     * @see TelephonyManager#NETWORK_TYPE_LTE</div><div>     * @see TelephonyManager#NETWORK_TYPE_EHRPD</div><div>     * @see TelephonyManager#NETWORK_TYPE_HSPAP</div><div>     *</div><div>     * &lt;p class=&quot;note&quot;&gt;</div><div>     * Retrieve with</div><div>     * {@link android.content.Intent#getIntExtra(String name, int defaultValue)}.</div><div>     *</div><div>     * @hide</div><div>     */</div><div>    public static final String EXTRA_DATA_NETWORK_TYPE = PhoneConstants.DATA_NETWORK_TYPE_KEY;</div><div><br/></div><div>    /**</div><div>     * The lookup key used with the {@link #ACTION_PRECISE_DATA_CONNECTION_STATE_CHANGED} broadcast</div><div>     * for an String containing the data APN type.</div><div>     *</div><div>     * &lt;p class=&quot;note&quot;&gt;</div><div>     * Retrieve with</div><div>     * {@link android.content.Intent#getStringExtra(String name)}.</div><div>     *</div><div>     * @hide</div><div>     */</div><div>    public static final String EXTRA_DATA_APN_TYPE = PhoneConstants.DATA_APN_TYPE_KEY;</div><div><br/></div><div>    /**</div><div>     * The lookup key used with the {@link #ACTION_PRECISE_DATA_CONNECTION_STATE_CHANGED} broadcast</div><div>     * for an String containing the data APN.</div><div>     *</div><div>     * &lt;p class=&quot;note&quot;&gt;</div><div>     * Retrieve with</div><div>     * {@link android.content.Intent#getStringExtra(String name)}.</div><div>     *</div><div>     * @hide</div><div>     */</div><div>    public static final String EXTRA_DATA_APN = PhoneConstants.DATA_APN_KEY;</div><div><br/></div><div>    /**</div><div>     * The lookup key used with the {@link #ACTION_PRECISE_DATA_CONNECTION_STATE_CHANGED} broadcast</div><div>     * for an String representation of the change reason.</div><div>     *</div><div>     * &lt;p class=&quot;note&quot;&gt;</div><div>     * Retrieve with</div><div>     * {@link android.content.Intent#getStringExtra(String name)}.</div><div>     *</div><div>     * @hide</div><div>     */</div><div>    public static final String EXTRA_DATA_CHANGE_REASON = PhoneConstants.STATE_CHANGE_REASON_KEY;</div><div><br/></div><div>    /**</div><div>     * The lookup key used with the {@link #ACTION_PRECISE_DATA_CONNECTION_STATE_CHANGED} broadcast</div><div>     * for an String representation of the data interface.</div><div>     *</div><div>     * &lt;p class=&quot;note&quot;&gt;</div><div>     * Retrieve with</div><div>     * {@link android.content.Intent#getParcelableExtra(String name)}.</div><div>     *</div><div>     * @hide</div><div>     */</div><div>    public static final String EXTRA_DATA_LINK_PROPERTIES_KEY = PhoneConstants.DATA_LINK_PROPERTIES_KEY;</div><div><br/></div><div>    /**</div><div>     * The lookup key used with the {@link #ACTION_PRECISE_DATA_CONNECTION_STATE_CHANGED} broadcast</div><div>     * for the data connection fail cause.</div><div>     *</div><div>     * &lt;p class=&quot;note&quot;&gt;</div><div>     * Retrieve with</div><div>     * {@link android.content.Intent#getStringExtra(String name)}.</div><div>     *</div><div>     * @hide</div><div>     */</div><div>    public static final String EXTRA_DATA_FAILURE_CAUSE = PhoneConstants.DATA_FAILURE_CAUSE_KEY;</div><div><br/></div><div>    //</div><div>    //</div><div>    // Device Info</div><div>    //</div><div>    //</div><div><br/></div><div>    /**</div><div>     * Returns the software version number for the device, for example,</div><div>     * the IMEI/SV for GSM phones. Return null if the software version is</div><div>     * not available.</div><div>     *</div><div>     * &lt;p&gt;Requires Permission:</div><div>     *   {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}</div><div>     */</div><div>    public String getDeviceSoftwareVersion() {</div><div>        return getDeviceSoftwareVersion(getDefaultSim());</div><div>    }</div><div>    /**</div><div>     * Returns the software version number for the device, for example,</div><div>     * the IMEI/SV for GSM phones. Return null if the software version is</div><div>     * not available.</div><div>     *</div><div>     * &lt;p&gt;Requires Permission:</div><div>     *   {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}</div><div>     *</div><div>     * @param slotId of which deviceID is returned</div><div>     */</div><div>    /** {@hide} */</div><div>    public String getDeviceSoftwareVersion(int slotId) {</div><div>        // FIXME methods taking slot id should not use subscription, instead us Uicc directly</div><div>        int[] subId = SubscriptionManager.getSubId(slotId);</div><div>        if (subId == null || subId.length == 0) {</div><div>            return null;</div><div>        }</div><div>        try {</div><div>            return getSubscriberInfo().getDeviceSvnUsingSubId(subId[0]);</div><div>        } catch (RemoteException ex) {</div><div>            Rlog.e(TAG, &quot;getDeviceSoftwareVersion error, return null. (slotId: &quot; + slotId + &quot;)&quot;);</div><div>            ex.printStackTrace();</div><div>            return null;</div><div>        } catch (NullPointerException ex) {</div><div>            Rlog.e(TAG, &quot;getDeviceSoftwareVersion error, return null. (slotId: &quot; + slotId + &quot;)&quot;);</div><div>            ex.printStackTrace();</div><div>            return null;</div><div>        }</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns the unique device ID, for example, the IMEI for GSM and the MEID</div><div>     * or ESN for CDMA phones. Return null if device ID is not available.</div><div>     *</div><div>     * &lt;p&gt;Requires Permission:</div><div>     *   {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}</div><div>     */</div><div>    public String getDeviceId() {</div><div>        try {</div><div>            return getITelephony().getDeviceId();</div><div>        } catch (RemoteException ex) {</div><div>            return null;</div><div>        } catch (NullPointerException ex) {</div><div>            return null;</div><div>        }</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns the unique device ID of a subscription, for example, the IMEI for</div><div>     * GSM and the MEID for CDMA phones. Return null if device ID is not available.</div><div>     *</div><div>     * &lt;p&gt;Requires Permission:</div><div>     *   {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}</div><div>     *</div><div>     * @param slotId of which deviceID is returned</div><div>     */</div><div>    /** {@hide} */</div><div>    public String getDeviceId(int slotId) {</div><div>        // FIXME this assumes phoneId == slotId</div><div>        try {</div><div>            return getSubscriberInfo().getDeviceIdForPhone(slotId);</div><div>        } catch (RemoteException ex) {</div><div>            return null;</div><div>        } catch (NullPointerException ex) {</div><div>            return null;</div><div>        }</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns the IMEI. Return null if IMEI is not available.</div><div>     *</div><div>     * &lt;p&gt;Requires Permission:</div><div>     *   {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}</div><div>     */</div><div>    /** {@hide} */</div><div>    public String getImei() {</div><div>        return getImei(getDefaultSim());</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns the IMEI. Return null if IMEI is not available.</div><div>     *</div><div>     * &lt;p&gt;Requires Permission:</div><div>     *   {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}</div><div>     *</div><div>     * @param slotId of which deviceID is returned</div><div>     */</div><div>    /** {@hide} */</div><div>    public String getImei(int slotId) {</div><div>        int[] subId = SubscriptionManager.getSubId(slotId);</div><div>        try {</div><div>            return getSubscriberInfo().getImeiForSubscriber(subId[0]);</div><div>        } catch (RemoteException ex) {</div><div>            return null;</div><div>        } catch (NullPointerException ex) {</div><div>            return null;</div><div>        }</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns the NAI. Return null if NAI is not available.</div><div>     *</div><div>     */</div><div>    /** {@hide}*/</div><div>    public String getNai() {</div><div>        return getNai(getDefaultSim());</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns the NAI. Return null if NAI is not available.</div><div>     *</div><div>     *  @param slotId of which Nai is returned</div><div>     */</div><div>    /** {@hide}*/</div><div>    public String getNai(int slotId) {</div><div>        int[] subId = SubscriptionManager.getSubId(slotId);</div><div>        try {</div><div>            String nai = getSubscriberInfo().getNaiForSubscriber(subId[0]);</div><div>            if (Log.isLoggable(TAG, Log.VERBOSE)) {</div><div>                Rlog.v(TAG, &quot;Nai = &quot; + nai);</div><div>            }</div><div>            return nai;</div><div>        } catch (RemoteException ex) {</div><div>            return null;</div><div>        } catch (NullPointerException ex) {</div><div>            return null;</div><div>        }</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns the current location of the device.</div><div>     *&lt;p&gt;</div><div>     * If there is only one radio in the device and that radio has an LTE connection,</div><div>     * this method will return null. The implementation must not to try add LTE</div><div>     * identifiers into the existing cdma/gsm classes.</div><div>     *&lt;p&gt;</div><div>     * In the future this call will be deprecated.</div><div>     *&lt;p&gt;</div><div>     * @return Current location of the device or null if not available.</div><div>     *</div><div>     * &lt;p&gt;Requires Permission:</div><div>     * {@link android.Manifest.permission#ACCESS_COARSE_LOCATION ACCESS_COARSE_LOCATION} or</div><div>     * {@link android.Manifest.permission#ACCESS_COARSE_LOCATION ACCESS_FINE_LOCATION}.</div><div>     */</div><div>    public CellLocation getCellLocation() {</div><div>        try {</div><div>            Bundle bundle = getITelephony().getCellLocation();</div><div>            if (bundle.isEmpty()) return null;</div><div>            CellLocation cl = CellLocation.newFromBundle(bundle);</div><div>            if (cl.isEmpty())</div><div>                return null;</div><div>            return cl;</div><div>        } catch (RemoteException ex) {</div><div>            return null;</div><div>        } catch (NullPointerException ex) {</div><div>            return null;</div><div>        }</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Enables location update notifications.  {@link PhoneStateListener#onCellLocationChanged</div><div>     * PhoneStateListener.onCellLocationChanged} will be called on location updates.</div><div>     *</div><div>     * &lt;p&gt;Requires Permission: {@link android.Manifest.permission#CONTROL_LOCATION_UPDATES</div><div>     * CONTROL_LOCATION_UPDATES}</div><div>     *</div><div>     * @hide</div><div>     */</div><div>    public void enableLocationUpdates() {</div><div>            enableLocationUpdates(getDefaultSubscription());</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Enables location update notifications for a subscription.</div><div>     * {@link PhoneStateListener#onCellLocationChanged</div><div>     * PhoneStateListener.onCellLocationChanged} will be called on location updates.</div><div>     *</div><div>     * &lt;p&gt;Requires Permission: {@link android.Manifest.permission#CONTROL_LOCATION_UPDATES</div><div>     * CONTROL_LOCATION_UPDATES}</div><div>     *</div><div>     * @param subId for which the location updates are enabled</div><div>     */</div><div>    /** @hide */</div><div>    public void enableLocationUpdates(int subId) {</div><div>        try {</div><div>            getITelephony().enableLocationUpdatesForSubscriber(subId);</div><div>        } catch (RemoteException ex) {</div><div>        } catch (NullPointerException ex) {</div><div>        }</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Disables location update notifications.  {@link PhoneStateListener#onCellLocationChanged</div><div>     * PhoneStateListener.onCellLocationChanged} will be called on location updates.</div><div>     *</div><div>     * &lt;p&gt;Requires Permission: {@link android.Manifest.permission#CONTROL_LOCATION_UPDATES</div><div>     * CONTROL_LOCATION_UPDATES}</div><div>     *</div><div>     * @hide</div><div>     */</div><div>    public void disableLocationUpdates() {</div><div>            disableLocationUpdates(getDefaultSubscription());</div><div>    }</div><div><br/></div><div>    /** @hide */</div><div>    public void disableLocationUpdates(int subId) {</div><div>        try {</div><div>            getITelephony().disableLocationUpdatesForSubscriber(subId);</div><div>        } catch (RemoteException ex) {</div><div>        } catch (NullPointerException ex) {</div><div>        }</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns the neighboring cell information of the device. The getAllCellInfo is preferred</div><div>     * and use this only if getAllCellInfo return nulls or an empty list.</div><div>     *&lt;p&gt;</div><div>     * In the future this call will be deprecated.</div><div>     *&lt;p&gt;</div><div>     * @return List of NeighboringCellInfo or null if info unavailable.</div><div>     *</div><div>     * &lt;p&gt;Requires Permission:</div><div>     * (@link android.Manifest.permission#ACCESS_COARSE_UPDATES}</div><div>     */</div><div>    public List&lt;NeighboringCellInfo&gt; getNeighboringCellInfo() {</div><div>        try {</div><div>            return getITelephony().getNeighboringCellInfo(mContext.getOpPackageName());</div><div>        } catch (RemoteException ex) {</div><div>            return null;</div><div>        } catch (NullPointerException ex) {</div><div>            return null;</div><div>        }</div><div>    }</div><div><br/></div><div>    /** No phone radio. */</div><div>    public static final int PHONE_TYPE_NONE = PhoneConstants.PHONE_TYPE_NONE;</div><div>    /** Phone radio is GSM. */</div><div>    public static final int PHONE_TYPE_GSM = PhoneConstants.PHONE_TYPE_GSM;</div><div>    /** Phone radio is CDMA. */</div><div>    public static final int PHONE_TYPE_CDMA = PhoneConstants.PHONE_TYPE_CDMA;</div><div>    /** Phone is via SIP. */</div><div>    public static final int PHONE_TYPE_SIP = PhoneConstants.PHONE_TYPE_SIP;</div><div><br/></div><div>    /**</div><div>     * Returns the current phone type.</div><div>     * TODO: This is a last minute change and hence hidden.</div><div>     *</div><div>     * @see #PHONE_TYPE_NONE</div><div>     * @see #PHONE_TYPE_GSM</div><div>     * @see #PHONE_TYPE_CDMA</div><div>     * @see #PHONE_TYPE_SIP</div><div>     *</div><div>     * {@hide}</div><div>     */</div><div>    @SystemApi</div><div>    public int getCurrentPhoneType() {</div><div>        return getCurrentPhoneType(getDefaultSubscription());</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns a constant indicating the device phone type for a subscription.</div><div>     *</div><div>     * @see #PHONE_TYPE_NONE</div><div>     * @see #PHONE_TYPE_GSM</div><div>     * @see #PHONE_TYPE_CDMA</div><div>     *</div><div>     * @param subId for which phone type is returned</div><div>     */</div><div>    /** {@hide} */</div><div>    @SystemApi</div><div>    public int getCurrentPhoneType(int subId) {</div><div>        int phoneId = SubscriptionManager.getPhoneId(subId);</div><div>        try{</div><div>            ITelephony telephony = getITelephony();</div><div>            if (telephony != null) {</div><div>                return telephony.getActivePhoneTypeForSubscriber(subId);</div><div>            } else {</div><div>                // This can happen when the ITelephony interface is not up yet.</div><div>                return getPhoneTypeFromProperty(phoneId);</div><div>            }</div><div>        } catch (RemoteException ex) {</div><div>            // This shouldn't happen in the normal case, as a backup we</div><div>            // read from the system property.</div><div>            return getPhoneTypeFromProperty(phoneId);</div><div>        } catch (NullPointerException ex) {</div><div>            // This shouldn't happen in the normal case, as a backup we</div><div>            // read from the system property.</div><div>            return getPhoneTypeFromProperty(phoneId);</div><div>        }</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns a constant indicating the device phone type.  This</div><div>     * indicates the type of radio used to transmit voice calls.</div><div>     *</div><div>     * @see #PHONE_TYPE_NONE</div><div>     * @see #PHONE_TYPE_GSM</div><div>     * @see #PHONE_TYPE_CDMA</div><div>     * @see #PHONE_TYPE_SIP</div><div>     */</div><div>    public int getPhoneType() {</div><div>        if (!isVoiceCapable()) {</div><div>            return PHONE_TYPE_NONE;</div><div>        }</div><div>        return getCurrentPhoneType();</div><div>    }</div><div><br/></div><div>    private int getPhoneTypeFromProperty() {</div><div>        return getPhoneTypeFromProperty(getDefaultPhone());</div><div>    }</div><div><br/></div><div>    /** {@hide} */</div><div>    private int getPhoneTypeFromProperty(int phoneId) {</div><div>        String type = getTelephonyProperty(phoneId,</div><div>                TelephonyProperties.CURRENT_ACTIVE_PHONE, null);</div><div>        if (type == null || type.equals(&quot;&quot;)) {</div><div>            return getPhoneTypeFromNetworkType(phoneId);</div><div>        }</div><div>        return Integer.parseInt(type);</div><div>    }</div><div><br/></div><div>    private int getPhoneTypeFromNetworkType() {</div><div>        return getPhoneTypeFromNetworkType(getDefaultPhone());</div><div>    }</div><div><br/></div><div>    /** {@hide} */</div><div>    private int getPhoneTypeFromNetworkType(int phoneId) {</div><div>        // When the system property CURRENT_ACTIVE_PHONE, has not been set,</div><div>        // use the system property for default network type.</div><div>        // This is a fail safe, and can only happen at first boot.</div><div>        String mode = getTelephonyProperty(phoneId, &quot;ro.telephony.default_network&quot;, null);</div><div>        if (mode != null) {</div><div>            return TelephonyManager.getPhoneType(Integer.parseInt(mode));</div><div>        }</div><div>        return TelephonyManager.PHONE_TYPE_NONE;</div><div>    }</div><div><br/></div><div>    /**</div><div>     * This function returns the type of the phone, depending</div><div>     * on the network mode.</div><div>     *</div><div>     * @param networkMode</div><div>     * @return Phone Type</div><div>     *</div><div>     * @hide</div><div>     */</div><div>    public static int getPhoneType(int networkMode) {</div><div>        switch(networkMode) {</div><div>        case RILConstants.NETWORK_MODE_CDMA:</div><div>        case RILConstants.NETWORK_MODE_CDMA_NO_EVDO:</div><div>        case RILConstants.NETWORK_MODE_EVDO_NO_CDMA:</div><div>            return PhoneConstants.PHONE_TYPE_CDMA;</div><div><br/></div><div>        case RILConstants.NETWORK_MODE_WCDMA_PREF:</div><div>        case RILConstants.NETWORK_MODE_GSM_ONLY:</div><div>        case RILConstants.NETWORK_MODE_WCDMA_ONLY:</div><div>        case RILConstants.NETWORK_MODE_GSM_UMTS:</div><div>        case RILConstants.NETWORK_MODE_LTE_GSM_WCDMA:</div><div>        case RILConstants.NETWORK_MODE_LTE_WCDMA:</div><div>        case RILConstants.NETWORK_MODE_LTE_CDMA_EVDO_GSM_WCDMA:</div><div>            return PhoneConstants.PHONE_TYPE_GSM;</div><div><br/></div><div>        // Use CDMA Phone for the global mode including CDMA</div><div>        case RILConstants.NETWORK_MODE_GLOBAL:</div><div>        case RILConstants.NETWORK_MODE_LTE_CDMA_EVDO:</div><div>            return PhoneConstants.PHONE_TYPE_CDMA;</div><div><br/></div><div>        case RILConstants.NETWORK_MODE_LTE_ONLY:</div><div>            if (getLteOnCdmaModeStatic() == PhoneConstants.LTE_ON_CDMA_TRUE) {</div><div>                return PhoneConstants.PHONE_TYPE_CDMA;</div><div>            } else {</div><div>                return PhoneConstants.PHONE_TYPE_GSM;</div><div>            }</div><div>        default:</div><div>            return PhoneConstants.PHONE_TYPE_GSM;</div><div>        }</div><div>    }</div><div><br/></div><div>    /**</div><div>     * The contents of the /proc/cmdline file</div><div>     */</div><div>    private static String getProcCmdLine()</div><div>    {</div><div>        String cmdline = &quot;&quot;;</div><div>        FileInputStream is = null;</div><div>        try {</div><div>            is = new FileInputStream(&quot;/proc/cmdline&quot;);</div><div>            byte [] buffer = new byte[2048];</div><div>            int count = is.read(buffer);</div><div>            if (count &gt; 0) {</div><div>                cmdline = new String(buffer, 0, count);</div><div>            }</div><div>        } catch (IOException e) {</div><div>            Rlog.d(TAG, &quot;No /proc/cmdline exception=&quot; + e);</div><div>        } finally {</div><div>            if (is != null) {</div><div>                try {</div><div>                    is.close();</div><div>                } catch (IOException e) {</div><div>                }</div><div>            }</div><div>        }</div><div>        Rlog.d(TAG, &quot;/proc/cmdline=&quot; + cmdline);</div><div>        return cmdline;</div><div>    }</div><div><br/></div><div>    /** Kernel command line */</div><div>    private static final String sKernelCmdLine = getProcCmdLine();</div><div><br/></div><div>    /** Pattern for selecting the product type from the kernel command line */</div><div>    private static final Pattern sProductTypePattern =</div><div>        Pattern.compile(&quot;\\sproduct_type\\s*=\\s*(\\w+)&quot;);</div><div><br/></div><div>    /** The ProductType used for LTE on CDMA devices */</div><div>    private static final String sLteOnCdmaProductType =</div><div>        SystemProperties.get(TelephonyProperties.PROPERTY_LTE_ON_CDMA_PRODUCT_TYPE, &quot;&quot;);</div><div><br/></div><div>    /**</div><div>     * Return if the current radio is LTE on CDMA. This</div><div>     * is a tri-state return value as for a period of time</div><div>     * the mode may be unknown.</div><div>     *</div><div>     * @return {@link PhoneConstants#LTE_ON_CDMA_UNKNOWN}, {@link PhoneConstants#LTE_ON_CDMA_FALSE}</div><div>     * or {@link PhoneConstants#LTE_ON_CDMA_TRUE}</div><div>     *</div><div>     * @hide</div><div>     */</div><div>    public static int getLteOnCdmaModeStatic() {</div><div>        int retVal;</div><div>        int curVal;</div><div>        String productType = &quot;&quot;;</div><div><br/></div><div>        curVal = SystemProperties.getInt(TelephonyProperties.PROPERTY_LTE_ON_CDMA_DEVICE,</div><div>                    PhoneConstants.LTE_ON_CDMA_UNKNOWN);</div><div>        retVal = curVal;</div><div>        if (retVal == PhoneConstants.LTE_ON_CDMA_UNKNOWN) {</div><div>            Matcher matcher = sProductTypePattern.matcher(sKernelCmdLine);</div><div>            if (matcher.find()) {</div><div>                productType = matcher.group(1);</div><div>                if (sLteOnCdmaProductType.equals(productType)) {</div><div>                    retVal = PhoneConstants.LTE_ON_CDMA_TRUE;</div><div>                } else {</div><div>                    retVal = PhoneConstants.LTE_ON_CDMA_FALSE;</div><div>                }</div><div>            } else {</div><div>                retVal = PhoneConstants.LTE_ON_CDMA_FALSE;</div><div>            }</div><div>        }</div><div><br/></div><div>        Rlog.d(TAG, &quot;getLteOnCdmaMode=&quot; + retVal + &quot; curVal=&quot; + curVal +</div><div>                &quot; product_type='&quot; + productType +</div><div>                &quot;' lteOnCdmaProductType='&quot; + sLteOnCdmaProductType + &quot;'&quot;);</div><div>        return retVal;</div><div>    }</div><div><br/></div><div>    //</div><div>    //</div><div>    // Current Network</div><div>    //</div><div>    //</div><div><br/></div><div>    /**</div><div>     * Returns the alphabetic name of current registered operator.</div><div>     * &lt;p&gt;</div><div>     * Availability: Only when user is registered to a network. Result may be</div><div>     * unreliable on CDMA networks (use {@link #getPhoneType()} to determine if</div><div>     * on a CDMA network).</div><div>     */</div><div>    public String getNetworkOperatorName() {</div><div>        return getNetworkOperatorName(getDefaultSubscription());</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns the alphabetic name of current registered operator</div><div>     * for a particular subscription.</div><div>     * &lt;p&gt;</div><div>     * Availability: Only when user is registered to a network. Result may be</div><div>     * unreliable on CDMA networks (use {@link #getPhoneType()} to determine if</div><div>     * on a CDMA network).</div><div>     * @param subId</div><div>     */</div><div>    /** {@hide} */</div><div>    public String getNetworkOperatorName(int subId) {</div><div>        //[ALPS01804936]-start:fix JE when change system language to &quot;Burmese&quot;</div><div>        //return getTelephonyProperty(TelephonyProperties.PROPERTY_OPERATOR_ALPHA,</div><div>        //        subId, &quot;&quot;);</div><div><br/></div><div>        int phoneId = SubscriptionManager.getPhoneId(subId);</div><div>        Rlog.d(TAG, &quot;getNetworkOperatorName phoneId= &quot; + phoneId);</div><div>        if ((phoneId &gt;= 0) &amp;&amp; (phoneId &lt; getPhoneCount())) {</div><div>            if (phoneId == PhoneConstants.SIM_ID_4) {</div><div>                return SystemProperties.get(TelephonyProperties.PROPERTY_OPERATOR_ALPHA_4);</div><div>            } else if (phoneId == PhoneConstants.SIM_ID_3) {</div><div>                return SystemProperties.get(TelephonyProperties.PROPERTY_OPERATOR_ALPHA_3);</div><div>            } else if (phoneId == PhoneConstants.SIM_ID_2) {</div><div>                return SystemProperties.get(TelephonyProperties.PROPERTY_OPERATOR_ALPHA_2);</div><div>            } else {</div><div>                return SystemProperties.get(TelephonyProperties.PROPERTY_OPERATOR_ALPHA);</div><div>            }</div><div>        }</div><div>        return &quot;&quot;;</div><div>        //[ALPS01804936]-end</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns the numeric name (MCC+MNC) of current registered operator.</div><div>     * &lt;p&gt;</div><div>     * Availability: Only when user is registered to a network. Result may be</div><div>     * unreliable on CDMA networks (use {@link #getPhoneType()} to determine if</div><div>     * on a CDMA network).</div><div>     */</div><div>    public String getNetworkOperator() {</div><div>        return getNetworkOperatorForPhone(getDefaultPhone());</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns the numeric name (MCC+MNC) of current registered operator</div><div>     * for a particular subscription.</div><div>     * &lt;p&gt;</div><div>     * Availability: Only when user is registered to a network. Result may be</div><div>     * unreliable on CDMA networks (use {@link #getPhoneType()} to determine if</div><div>     * on a CDMA network).</div><div>     *</div><div>     * @param subId</div><div>     */</div><div>    /** {@hide} */</div><div>   public String getNetworkOperatorForSubscription(int subId) {</div><div>        int phoneId = SubscriptionManager.getPhoneId(subId);</div><div>        return getNetworkOperatorForPhone(phoneId);</div><div>     }</div><div><br/></div><div>    /**</div><div>     * Returns the numeric name (MCC+MNC) of current registered operator</div><div>     * for a particular subscription.</div><div>     * &lt;p&gt;</div><div>     * Availability: Only when user is registered to a network. Result may be</div><div>     * unreliable on CDMA networks (use {@link #getPhoneType()} to determine if</div><div>     * on a CDMA network).</div><div>     *</div><div>     * @param phoneId</div><div>     * @hide</div><div>     **/</div><div>   public String getNetworkOperatorForPhone(int phoneId) {</div><div>        return getTelephonyProperty(phoneId, TelephonyProperties.PROPERTY_OPERATOR_NUMERIC, &quot;&quot;);</div><div>     }</div><div><br/></div><div>    /**</div><div>     * Returns true if the device is considered roaming on the current</div><div>     * network, for GSM purposes.</div><div>     * &lt;p&gt;</div><div>     * Availability: Only when user registered to a network.</div><div>     */</div><div>    public boolean isNetworkRoaming() {</div><div>        return isNetworkRoaming(getDefaultSubscription());</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns true if the device is considered roaming on the current</div><div>     * network for a subscription.</div><div>     * &lt;p&gt;</div><div>     * Availability: Only when user registered to a network.</div><div>     *</div><div>     * @param subId</div><div>     */</div><div>    /** {@hide} */</div><div>    public boolean isNetworkRoaming(int subId) {</div><div>        int phoneId = SubscriptionManager.getPhoneId(subId);</div><div>        return Boolean.parseBoolean(getTelephonyProperty(phoneId,</div><div>                TelephonyProperties.PROPERTY_OPERATOR_ISROAMING, null));</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns the ISO country code equivalent of the current registered</div><div>     * operator's MCC (Mobile Country Code).</div><div>     * &lt;p&gt;</div><div>     * Availability: Only when user is registered to a network. Result may be</div><div>     * unreliable on CDMA networks (use {@link #getPhoneType()} to determine if</div><div>     * on a CDMA network).</div><div>     */</div><div>    public String getNetworkCountryIso() {</div><div>        return getNetworkCountryIsoForPhone(getDefaultPhone());</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns the ISO country code equivalent of the current registered</div><div>     * operator's MCC (Mobile Country Code) of a subscription.</div><div>     * &lt;p&gt;</div><div>     * Availability: Only when user is registered to a network. Result may be</div><div>     * unreliable on CDMA networks (use {@link #getPhoneType()} to determine if</div><div>     * on a CDMA network).</div><div>     *</div><div>     * @param subId for which Network CountryIso is returned</div><div>     */</div><div>    /** {@hide} */</div><div>    public String getNetworkCountryIsoForSubscription(int subId) {</div><div>        int phoneId = SubscriptionManager.getPhoneId(subId);</div><div>        return getNetworkCountryIsoForPhone(phoneId);</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns the ISO country code equivalent of the current registered</div><div>     * operator's MCC (Mobile Country Code) of a subscription.</div><div>     * &lt;p&gt;</div><div>     * Availability: Only when user is registered to a network. Result may be</div><div>     * unreliable on CDMA networks (use {@link #getPhoneType()} to determine if</div><div>     * on a CDMA network).</div><div>     *</div><div>     * @param phoneId for which Network CountryIso is returned</div><div>     */</div><div>    /** {@hide} */</div><div>    public String getNetworkCountryIsoForPhone(int phoneId) {</div><div>        return getTelephonyProperty(phoneId, TelephonyProperties.PROPERTY_OPERATOR_ISO_COUNTRY, &quot;&quot;);</div><div>    }</div><div><br/></div><div>    /** Network type is unknown */</div><div>    public static final int NETWORK_TYPE_UNKNOWN = 0;</div><div>    /** Current network is GPRS */</div><div>    public static final int NETWORK_TYPE_GPRS = 1;</div><div>    /** Current network is EDGE */</div><div>    public static final int NETWORK_TYPE_EDGE = 2;</div><div>    /** Current network is UMTS */</div><div>    public static final int NETWORK_TYPE_UMTS = 3;</div><div>    /** Current network is CDMA: Either IS95A or IS95B*/</div><div>    public static final int NETWORK_TYPE_CDMA = 4;</div><div>    /** Current network is EVDO revision 0*/</div><div>    public static final int NETWORK_TYPE_EVDO_0 = 5;</div><div>    /** Current network is EVDO revision A*/</div><div>    public static final int NETWORK_TYPE_EVDO_A = 6;</div><div>    /** Current network is 1xRTT*/</div><div>    public static final int NETWORK_TYPE_1xRTT = 7;</div><div>    /** Current network is HSDPA */</div><div>    public static final int NETWORK_TYPE_HSDPA = 8;</div><div>    /** Current network is HSUPA */</div><div>    public static final int NETWORK_TYPE_HSUPA = 9;</div><div>    /** Current network is HSPA */</div><div>    public static final int NETWORK_TYPE_HSPA = 10;</div><div>    /** Current network is iDen */</div><div>    public static final int NETWORK_TYPE_IDEN = 11;</div><div>    /** Current network is EVDO revision B*/</div><div>    public static final int NETWORK_TYPE_EVDO_B = 12;</div><div>    /** Current network is LTE */</div><div>    public static final int NETWORK_TYPE_LTE = 13;</div><div>    /** Current network is eHRPD */</div><div>    public static final int NETWORK_TYPE_EHRPD = 14;</div><div>    /** Current network is HSPA+ */</div><div>    public static final int NETWORK_TYPE_HSPAP = 15;</div><div>    /** Current network is GSM {@hide} */</div><div>    public static final int NETWORK_TYPE_GSM = 16;</div><div><br/></div><div>    /** M: start */</div><div>    /**</div><div>     * MTK network type base</div><div>     * @hide</div><div>     */</div><div>    public static final int NETWORK_TYPE_MTK_BASE = 128;</div><div>    /**</div><div>     * Current network is HSDPAP</div><div>     * @hide</div><div>     */</div><div>    public static final int NETWORK_TYPE_HSDPAP = NETWORK_TYPE_MTK_BASE + 1;</div><div>    /**</div><div>     * Current network is HSDPAP_UPA</div><div>     * @hide</div><div>     */</div><div>    public static final int NETWORK_TYPE_HSDPAP_UPA = NETWORK_TYPE_MTK_BASE + 2;</div><div>    /**</div><div>     * Current network is HSUPAP</div><div>     * @hide</div><div>     */</div><div>    public static final int NETWORK_TYPE_HSUPAP = NETWORK_TYPE_MTK_BASE + 3;</div><div>    /**</div><div>     * Current network is HSUPAP_DPA</div><div>     * @hide</div><div>     */</div><div>    public static final int NETWORK_TYPE_HSUPAP_DPA = NETWORK_TYPE_MTK_BASE + 4;</div><div>    /**</div><div>     * Current network is DC_DPA</div><div>     * @hide</div><div>     */</div><div>    public static final int NETWORK_TYPE_DC_DPA = NETWORK_TYPE_MTK_BASE + 5;</div><div>    /**</div><div>     * Current network is DC_UPA</div><div>     * @hide</div><div>     */</div><div>    public static final int NETWORK_TYPE_DC_UPA = NETWORK_TYPE_MTK_BASE + 6;</div><div>    /**</div><div>     * Current network is DC_HSDPAP</div><div>     * @hide</div><div>     */</div><div>    public static final int NETWORK_TYPE_DC_HSDPAP = NETWORK_TYPE_MTK_BASE + 7;</div><div>    /**</div><div>     * Current network is DC_HSDPAP_UPA</div><div>     * @hide</div><div>     */</div><div>    public static final int NETWORK_TYPE_DC_HSDPAP_UPA = NETWORK_TYPE_MTK_BASE + 8;</div><div>    /**</div><div>     * Current network is DC_HSDPAP_DPA</div><div>     * @hide</div><div>     */</div><div>    public static final int NETWORK_TYPE_DC_HSDPAP_DPA = NETWORK_TYPE_MTK_BASE + 9;</div><div>    /**</div><div>     * Current network is DC_HSPAP</div><div>     * @hide</div><div>     */</div><div>    public static final int NETWORK_TYPE_DC_HSPAP = NETWORK_TYPE_MTK_BASE + 10;</div><div>    /** M: end */</div><div><br/></div><div>    /**</div><div>     * @return the NETWORK_TYPE_xxxx for current data connection.</div><div>     */</div><div>    public int getNetworkType() {</div><div>        return getDataNetworkType();</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns a constant indicating the radio technology (network type)</div><div>     * currently in use on the device for a subscription.</div><div>     * @return the network type</div><div>     *</div><div>     * @param subId for which network type is returned</div><div>     *</div><div>     * @see #NETWORK_TYPE_UNKNOWN</div><div>     * @see #NETWORK_TYPE_GPRS</div><div>     * @see #NETWORK_TYPE_EDGE</div><div>     * @see #NETWORK_TYPE_UMTS</div><div>     * @see #NETWORK_TYPE_HSDPA</div><div>     * @see #NETWORK_TYPE_HSUPA</div><div>     * @see #NETWORK_TYPE_HSPA</div><div>     * @see #NETWORK_TYPE_CDMA</div><div>     * @see #NETWORK_TYPE_EVDO_0</div><div>     * @see #NETWORK_TYPE_EVDO_A</div><div>     * @see #NETWORK_TYPE_EVDO_B</div><div>     * @see #NETWORK_TYPE_1xRTT</div><div>     * @see #NETWORK_TYPE_IDEN</div><div>     * @see #NETWORK_TYPE_LTE</div><div>     * @see #NETWORK_TYPE_EHRPD</div><div>     * @see #NETWORK_TYPE_HSPAP</div><div>     */</div><div>    /** {@hide} */</div><div>   public int getNetworkType(int subId) {</div><div>       try {</div><div>           ITelephony telephony = getITelephony();</div><div>           if (telephony != null) {</div><div>               return telephony.getNetworkTypeForSubscriber(subId);</div><div>           } else {</div><div>               // This can happen when the ITelephony interface is not up yet.</div><div>               return NETWORK_TYPE_UNKNOWN;</div><div>           }</div><div>       } catch(RemoteException ex) {</div><div>           // This shouldn't happen in the normal case</div><div>           return NETWORK_TYPE_UNKNOWN;</div><div>       } catch (NullPointerException ex) {</div><div>           // This could happen before phone restarts due to crashing</div><div>           return NETWORK_TYPE_UNKNOWN;</div><div>       }</div><div>   }</div><div><br/></div><div>    /**</div><div>     * Returns a constant indicating the radio technology (network type)</div><div>     * currently in use on the device for data transmission.</div><div>     * @return the network type</div><div>     *</div><div>     * @see #NETWORK_TYPE_UNKNOWN</div><div>     * @see #NETWORK_TYPE_GPRS</div><div>     * @see #NETWORK_TYPE_EDGE</div><div>     * @see #NETWORK_TYPE_UMTS</div><div>     * @see #NETWORK_TYPE_HSDPA</div><div>     * @see #NETWORK_TYPE_HSUPA</div><div>     * @see #NETWORK_TYPE_HSPA</div><div>     * @see #NETWORK_TYPE_CDMA</div><div>     * @see #NETWORK_TYPE_EVDO_0</div><div>     * @see #NETWORK_TYPE_EVDO_A</div><div>     * @see #NETWORK_TYPE_EVDO_B</div><div>     * @see #NETWORK_TYPE_1xRTT</div><div>     * @see #NETWORK_TYPE_IDEN</div><div>     * @see #NETWORK_TYPE_LTE</div><div>     * @see #NETWORK_TYPE_EHRPD</div><div>     * @see #NETWORK_TYPE_HSPAP</div><div>     *</div><div>     * @hide</div><div>     */</div><div>    public int getDataNetworkType() {</div><div>        return getDataNetworkType(getDefaultSubscription());</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns a constant indicating the radio technology (network type)</div><div>     * currently in use on the device for data transmission for a subscription</div><div>     * @return the network type</div><div>     *</div><div>     * @param subId for which network type is returned</div><div>     */</div><div>    /** {@hide} */</div><div>    public int getDataNetworkType(int subId) {</div><div>        try{</div><div>            ITelephony telephony = getITelephony();</div><div>            if (telephony != null) {</div><div>                return telephony.getDataNetworkTypeForSubscriber(subId);</div><div>            } else {</div><div>                // This can happen when the ITelephony interface is not up yet.</div><div>                return NETWORK_TYPE_UNKNOWN;</div><div>            }</div><div>        } catch(RemoteException ex) {</div><div>            // This shouldn't happen in the normal case</div><div>            return NETWORK_TYPE_UNKNOWN;</div><div>        } catch (NullPointerException ex) {</div><div>            // This could happen before phone restarts due to crashing</div><div>            return NETWORK_TYPE_UNKNOWN;</div><div>        }</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns the NETWORK_TYPE_xxxx for voice</div><div>     *</div><div>     * @hide</div><div>     */</div><div>    public int getVoiceNetworkType() {</div><div>        return getVoiceNetworkType(getDefaultSubscription());</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns the NETWORK_TYPE_xxxx for voice for a subId</div><div>     *</div><div>     */</div><div>    /** {@hide} */</div><div>    public int getVoiceNetworkType(int subId) {</div><div>        try{</div><div>            ITelephony telephony = getITelephony();</div><div>            if (telephony != null) {</div><div>                return telephony.getVoiceNetworkTypeForSubscriber(subId);</div><div>            } else {</div><div>                // This can happen when the ITelephony interface is not up yet.</div><div>                return NETWORK_TYPE_UNKNOWN;</div><div>            }</div><div>        } catch(RemoteException ex) {</div><div>            // This shouldn't happen in the normal case</div><div>            return NETWORK_TYPE_UNKNOWN;</div><div>        } catch (NullPointerException ex) {</div><div>            // This could happen before phone restarts due to crashing</div><div>            return NETWORK_TYPE_UNKNOWN;</div><div>        }</div><div>    }</div><div><br/></div><div>    /** Unknown network class. {@hide} */</div><div>    public static final int NETWORK_CLASS_UNKNOWN = 0;</div><div>    /** Class of broadly defined &quot;2G&quot; networks. {@hide} */</div><div>    public static final int NETWORK_CLASS_2_G = 1;</div><div>    /** Class of broadly defined &quot;3G&quot; networks. {@hide} */</div><div>    public static final int NETWORK_CLASS_3_G = 2;</div><div>    /** Class of broadly defined &quot;4G&quot; networks. {@hide} */</div><div>    public static final int NETWORK_CLASS_4_G = 3;</div><div><br/></div><div>    /**</div><div>     * Return general class of network type, such as &quot;3G&quot; or &quot;4G&quot;. In cases</div><div>     * where classification is contentious, this method is conservative.</div><div>     *</div><div>     * @hide</div><div>     */</div><div>    public static int getNetworkClass(int networkType) {</div><div>        switch (networkType) {</div><div>            case NETWORK_TYPE_GPRS:</div><div>            case NETWORK_TYPE_GSM:</div><div>            case NETWORK_TYPE_EDGE:</div><div>            case NETWORK_TYPE_CDMA:</div><div>            case NETWORK_TYPE_1xRTT:</div><div>            case NETWORK_TYPE_IDEN:</div><div>                return NETWORK_CLASS_2_G;</div><div>            case NETWORK_TYPE_UMTS:</div><div>            case NETWORK_TYPE_EVDO_0:</div><div>            case NETWORK_TYPE_EVDO_A:</div><div>            case NETWORK_TYPE_HSDPA:</div><div>            case NETWORK_TYPE_HSUPA:</div><div>            case NETWORK_TYPE_HSPA:</div><div>            case NETWORK_TYPE_EVDO_B:</div><div>            case NETWORK_TYPE_EHRPD:</div><div>            case NETWORK_TYPE_HSPAP:</div><div>                return NETWORK_CLASS_3_G;</div><div>            case NETWORK_TYPE_LTE:</div><div>                return NETWORK_CLASS_4_G;</div><div>            default:</div><div>                return NETWORK_CLASS_UNKNOWN;</div><div>        }</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns a string representation of the radio technology (network type)</div><div>     * currently in use on the device.</div><div>     * @return the name of the radio technology</div><div>     *</div><div>     * @hide pending API council review</div><div>     */</div><div>    public String getNetworkTypeName() {</div><div>        return getNetworkTypeName(getNetworkType());</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns a string representation of the radio technology (network type)</div><div>     * currently in use on the device.</div><div>     * @param subId for which network type is returned</div><div>     * @return the name of the radio technology</div><div>     *</div><div>     */</div><div>    /** {@hide} */</div><div>    public static String getNetworkTypeName(int type) {</div><div>        switch (type) {</div><div>            case NETWORK_TYPE_GPRS:</div><div>                return &quot;GPRS&quot;;</div><div>            case NETWORK_TYPE_EDGE:</div><div>                return &quot;EDGE&quot;;</div><div>            case NETWORK_TYPE_UMTS:</div><div>                return &quot;UMTS&quot;;</div><div>            case NETWORK_TYPE_HSDPA:</div><div>                return &quot;HSDPA&quot;;</div><div>            case NETWORK_TYPE_HSUPA:</div><div>                return &quot;HSUPA&quot;;</div><div>            case NETWORK_TYPE_HSPA:</div><div>                return &quot;HSPA&quot;;</div><div>            case NETWORK_TYPE_CDMA:</div><div>                return &quot;CDMA&quot;;</div><div>            case NETWORK_TYPE_EVDO_0:</div><div>                return &quot;CDMA - EvDo rev. 0&quot;;</div><div>            case NETWORK_TYPE_EVDO_A:</div><div>                return &quot;CDMA - EvDo rev. A&quot;;</div><div>            case NETWORK_TYPE_EVDO_B:</div><div>                return &quot;CDMA - EvDo rev. B&quot;;</div><div>            case NETWORK_TYPE_1xRTT:</div><div>                return &quot;CDMA - 1xRTT&quot;;</div><div>            case NETWORK_TYPE_LTE:</div><div>                return &quot;LTE&quot;;</div><div>            case NETWORK_TYPE_EHRPD:</div><div>                return &quot;CDMA - eHRPD&quot;;</div><div>            case NETWORK_TYPE_IDEN:</div><div>                return &quot;iDEN&quot;;</div><div>            case NETWORK_TYPE_HSPAP:</div><div>                return &quot;HSPA+&quot;;</div><div>            case NETWORK_TYPE_GSM:</div><div>                return &quot;GSM&quot;;</div><div>            default:</div><div>                return &quot;UNKNOWN&quot;;</div><div>        }</div><div>    }</div><div><br/></div><div>    //</div><div>    //</div><div>    // SIM Card</div><div>    //</div><div>    //</div><div><br/></div><div>    /**</div><div>     * SIM card state: Unknown. Signifies that the SIM is in transition</div><div>     * between states. For example, when the user inputs the SIM pin</div><div>     * under PIN_REQUIRED state, a query for sim status returns</div><div>     * this state before turning to SIM_STATE_READY.</div><div>     *</div><div>     * These are the ordinal value of IccCardConstants.State.</div><div>     */</div><div>    public static final int SIM_STATE_UNKNOWN = 0;</div><div>    /** SIM card state: no SIM card is available in the device */</div><div>    public static final int SIM_STATE_ABSENT = 1;</div><div>    /** SIM card state: Locked: requires the user's SIM PIN to unlock */</div><div>    public static final int SIM_STATE_PIN_REQUIRED = 2;</div><div>    /** SIM card state: Locked: requires the user's SIM PUK to unlock */</div><div>    public static final int SIM_STATE_PUK_REQUIRED = 3;</div><div>    /** SIM card state: Locked: requires a network PIN to unlock */</div><div>    public static final int SIM_STATE_NETWORK_LOCKED = 4;</div><div>    /** SIM card state: Ready */</div><div>    public static final int SIM_STATE_READY = 5;</div><div>    /** SIM card state: SIM Card is NOT READY</div><div>     *@hide</div><div>     */</div><div>    public static final int SIM_STATE_NOT_READY = 6;</div><div>    /** SIM card state: SIM Card Error, permanently disabled</div><div>     *@hide</div><div>     */</div><div>    public static final int SIM_STATE_PERM_DISABLED = 7;</div><div>    /** SIM card state: SIM Card Error, present but faulty</div><div>     *@hide</div><div>     */</div><div>    public static final int SIM_STATE_CARD_IO_ERROR = 8;</div><div><br/></div><div>    /**</div><div>     * @return true if a ICC card is present</div><div>     */</div><div>    public boolean hasIccCard() {</div><div>        return hasIccCard(getDefaultSim());</div><div>    }</div><div><br/></div><div>    /**</div><div>     * @return true if a ICC card is present for a subscription</div><div>     *</div><div>     * @param slotId for which icc card presence is checked</div><div>     */</div><div>    /** {@hide} */</div><div>    // FIXME Input argument slotId should be of type int</div><div>    public boolean hasIccCard(int slotId) {</div><div><br/></div><div>        try {</div><div>            return getITelephony().hasIccCardUsingSlotId(slotId);</div><div>        } catch (RemoteException ex) {</div><div>            // Assume no ICC card if remote exception which shouldn't happen</div><div>            return false;</div><div>        } catch (NullPointerException ex) {</div><div>            // This could happen before phone restarts due to crashing</div><div>            return false;</div><div>        }</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns a constant indicating the state of the default SIM card.</div><div>     *</div><div>     * @see #SIM_STATE_UNKNOWN</div><div>     * @see #SIM_STATE_ABSENT</div><div>     * @see #SIM_STATE_PIN_REQUIRED</div><div>     * @see #SIM_STATE_PUK_REQUIRED</div><div>     * @see #SIM_STATE_NETWORK_LOCKED</div><div>     * @see #SIM_STATE_READY</div><div>     * @see #SIM_STATE_NOT_READY</div><div>     * @see #SIM_STATE_PERM_DISABLED</div><div>     * @see #SIM_STATE_CARD_IO_ERROR</div><div>     */</div><div>    public int getSimState() {</div><div>        return getSimState(getDefaultSim());</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns a constant indicating the state of the device SIM card in a slot.</div><div>     *</div><div>     * @param slotIdx</div><div>     *</div><div>     * @see #SIM_STATE_UNKNOWN</div><div>     * @see #SIM_STATE_ABSENT</div><div>     * @see #SIM_STATE_PIN_REQUIRED</div><div>     * @see #SIM_STATE_PUK_REQUIRED</div><div>     * @see #SIM_STATE_NETWORK_LOCKED</div><div>     * @see #SIM_STATE_READY</div><div>     * @see #SIM_STATE_NOT_READY</div><div>     * @see #SIM_STATE_PERM_DISABLED</div><div>     * @see #SIM_STATE_CARD_IO_ERROR</div><div>     */</div><div>    /** {@hide} */</div><div>    public int getSimState(int slotIdx) {</div><div>        /// M: For MTK multiuser in 3gdatasms:MTK_ONLY_OWNER_SIM_SUPPORT @{</div><div>        if (mOnlyOwnerSimSupport != null &amp;&amp; !mOnlyOwnerSimSupport.isCurrentUserOwner()) {</div><div>            Rlog.d(TAG, &quot;getSimState return: 3gdatasms  MTK_ONLY_OWNER_SIM_SUPPORT &quot;);</div><div>            return SIM_STATE_UNKNOWN;</div><div>        }</div><div>        /// @}</div><div><br/></div><div>        int[] subId = SubscriptionManager.getSubId(slotIdx);</div><div>        if (subId == null || subId.length == 0) {</div><div>            Rlog.d(TAG, &quot;getSimState:- empty subId return SIM_STATE_ABSENT&quot;);</div><div>            return SIM_STATE_UNKNOWN;</div><div>        }</div><div>        int simState = SubscriptionManager.getSimStateForSubscriber(subId[0]);</div><div>        Rlog.d(TAG, &quot;getSimState: simState=&quot; + simState + &quot; slotIdx=&quot; + slotIdx);</div><div>        return simState;</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns the MCC+MNC (mobile country code + mobile network code) of the</div><div>     * provider of the SIM. 5 or 6 decimal digits.</div><div>     * &lt;p&gt;</div><div>     * Availability: SIM state must be {@link #SIM_STATE_READY}</div><div>     *</div><div>     * @see #getSimState</div><div>     */</div><div>    public String getSimOperator() {</div><div>        return getSimOperatorNumeric();</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns the MCC+MNC (mobile country code + mobile network code) of the</div><div>     * provider of the SIM. 5 or 6 decimal digits.</div><div>     * &lt;p&gt;</div><div>     * Availability: SIM state must be {@link #SIM_STATE_READY}</div><div>     *</div><div>     * @see #getSimState</div><div>     *</div><div>     * @param subId for which SimOperator is returned</div><div>     * @hide</div><div>     */</div><div>    public String getSimOperator(int subId) {</div><div>        return getSimOperatorNumericForSubscription(subId);</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns the MCC+MNC (mobile country code + mobile network code) of the</div><div>     * provider of the SIM. 5 or 6 decimal digits.</div><div>     * &lt;p&gt;</div><div>     * Availability: SIM state must be {@link #SIM_STATE_READY}</div><div>     *</div><div>     * @see #getSimState</div><div>     * @hide</div><div>     */</div><div>    public String getSimOperatorNumeric() {</div><div>        int subId = SubscriptionManager.getDefaultDataSubId();</div><div>        if (!SubscriptionManager.isUsableSubIdValue(subId)) {</div><div>            subId = SubscriptionManager.getDefaultSmsSubId();</div><div>            if (!SubscriptionManager.isUsableSubIdValue(subId)) {</div><div>                subId = SubscriptionManager.getDefaultVoiceSubId();</div><div>                if (!SubscriptionManager.isUsableSubIdValue(subId)) {</div><div>                    subId = SubscriptionManager.getDefaultSubId();</div><div>                }</div><div>            }</div><div>        }</div><div>        Rlog.d(TAG, &quot;getSimOperatorNumeric(): default subId=&quot; + subId);</div><div>        return getSimOperatorNumericForSubscription(subId);</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns the MCC+MNC (mobile country code + mobile network code) of the</div><div>     * provider of the SIM for a particular subscription. 5 or 6 decimal digits.</div><div>     * &lt;p&gt;</div><div>     * Availability: SIM state must be {@link #SIM_STATE_READY}</div><div>     *</div><div>     * @see #getSimState</div><div>     *</div><div>     * @param subId for which SimOperator is returned</div><div>     * @hide</div><div>     */</div><div>    public String getSimOperatorNumericForSubscription(int subId) {</div><div>        /// M: For MTK multiuser in 3gdatasms:MTK_ONLY_OWNER_SIM_SUPPORT @{</div><div>        if (mOnlyOwnerSimSupport != null &amp;&amp; !mOnlyOwnerSimSupport.isCurrentUserOwner()) {</div><div>            Rlog.d(TAG, &quot;getSimOperator return: 3gdatasms MTK_ONLY_OWNER_SIM_SUPPORT &quot;);</div><div>            return &quot;&quot;;</div><div>        }</div><div>        /// @}</div><div>        int phoneId = SubscriptionManager.getPhoneId(subId);</div><div>        return getSimOperatorNumericForPhone(phoneId);</div><div>    }</div><div><br/></div><div>   /**</div><div>     * Returns the MCC+MNC (mobile country code + mobile network code) of the</div><div>     * provider of the SIM for a particular subscription. 5 or 6 decimal digits.</div><div>     * &lt;p&gt;</div><div>     *</div><div>     * @param phoneId for which SimOperator is returned</div><div>     * @hide</div><div>     */</div><div>    public String getSimOperatorNumericForPhone(int phoneId) {</div><div>        return getTelephonyProperty(phoneId,</div><div>                TelephonyProperties.PROPERTY_ICC_OPERATOR_NUMERIC, &quot;&quot;);</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns the Service Provider Name (SPN).</div><div>     * &lt;p&gt;</div><div>     * Availability: SIM state must be {@link #SIM_STATE_READY}</div><div>     *</div><div>     * @see #getSimState</div><div>     */</div><div>    public String getSimOperatorName() {</div><div>        /// M: For MTK multiuser in 3gdatasms:MTK_ONLY_OWNER_SIM_SUPPORT @{</div><div>        if (mOnlyOwnerSimSupport != null &amp;&amp; !mOnlyOwnerSimSupport.isCurrentUserOwner()) {</div><div>            Rlog.d(TAG, &quot;getSimOperator return: 3gdatasms MTK_ONLY_OWNER_SIM_SUPPORT &quot;);</div><div>            return &quot;&quot;;</div><div>        }</div><div>        /// @}</div><div>        return getSimOperatorNameForPhone(getDefaultPhone());</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns the Service Provider Name (SPN).</div><div>     * &lt;p&gt;</div><div>     * Availability: SIM state must be {@link #SIM_STATE_READY}</div><div>     *</div><div>     * @see #getSimState</div><div>     *</div><div>     * @param subId for which SimOperatorName is returned</div><div>     * @hide</div><div>     */</div><div>    public String getSimOperatorNameForSubscription(int subId) {</div><div>        int phoneId = SubscriptionManager.getPhoneId(subId);</div><div>        return getSimOperatorNameForPhone(phoneId);</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns the Service Provider Name (SPN).</div><div>     *</div><div>     * @hide</div><div>     */</div><div>    public String getSimOperatorNameForPhone(int phoneId) {</div><div>         return getTelephonyProperty(phoneId,</div><div>                TelephonyProperties.PROPERTY_ICC_OPERATOR_ALPHA, &quot;&quot;);</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns the ISO country code equivalent for the SIM provider's country code.</div><div>     */</div><div>    public String getSimCountryIso() {</div><div>        return getSimCountryIsoForPhone(getDefaultPhone());</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns the ISO country code equivalent for the SIM provider's country code.</div><div>     *</div><div>     * @param subId for which SimCountryIso is returned</div><div>     *</div><div>     * @hide</div><div>     */</div><div>    public String getSimCountryIso(int subId) {</div><div>        return getSimCountryIsoForSubscription(subId);</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns the ISO country code equivalent for the SIM provider's country code.</div><div>     *</div><div>     * @param subId for which SimCountryIso is returned</div><div>     *</div><div>     * @hide</div><div>     */</div><div>    public String getSimCountryIsoForSubscription(int subId) {</div><div>        /// M: For MTK multiuser in 3gdatasms:MTK_ONLY_OWNER_SIM_SUPPORT @{</div><div>        if (mOnlyOwnerSimSupport != null &amp;&amp; !mOnlyOwnerSimSupport.isCurrentUserOwner()) {</div><div>            Rlog.d(TAG, &quot;getSimCountryIso return: 3gdatasms MTK_ONLY_OWNER_SIM_SUPPORT &quot;);</div><div>            return &quot;&quot;;</div><div>        }</div><div>        /// @}</div><div>        int phoneId = SubscriptionManager.getPhoneId(subId);</div><div>        return getSimCountryIsoForPhone(phoneId);</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns the ISO country code equivalent for the SIM provider's country code.</div><div>     *</div><div>     * @hide</div><div>     */</div><div>    public String getSimCountryIsoForPhone(int phoneId) {</div><div>        return getTelephonyProperty(phoneId,</div><div>                TelephonyProperties.PROPERTY_ICC_OPERATOR_ISO_COUNTRY, &quot;&quot;);</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns the serial number of the SIM, if applicable. Return null if it is</div><div>     * unavailable.</div><div>     * &lt;p&gt;</div><div>     * Requires Permission:</div><div>     *   {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}</div><div>     */</div><div>    public String getSimSerialNumber() {</div><div>         return getSimSerialNumber(getDefaultSubscription());</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns the serial number for the given subscription, if applicable. Return null if it is</div><div>     * unavailable.</div><div>     * &lt;p&gt;</div><div>     * @param subId for which Sim Serial number is returned</div><div>     * Requires Permission:</div><div>     *   {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}</div><div>     */</div><div>    /** {@hide} */</div><div>    public String getSimSerialNumber(int subId) {</div><div>        /// M: For MTK multiuser in 3gdatasms:MTK_ONLY_OWNER_SIM_SUPPORT @{</div><div>        if (mOnlyOwnerSimSupport != null &amp;&amp; !mOnlyOwnerSimSupport.isCurrentUserOwner()) {</div><div>            Rlog.d(TAG, &quot;getSimSerialNumber return: 3gdatasms MTK_ONLY_OWNER_SIM_SUPPORT &quot;);</div><div>            return &quot;&quot;;</div><div>        }</div><div>        /// @}</div><div>        try {</div><div>            return getSubscriberInfo().getIccSerialNumberForSubscriber(subId);</div><div>        } catch (RemoteException ex) {</div><div>            return null;</div><div>        } catch (NullPointerException ex) {</div><div>            // This could happen before phone restarts due to crashing</div><div>            return null;</div><div>        }</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Return if the current radio is LTE on CDMA. This</div><div>     * is a tri-state return value as for a period of time</div><div>     * the mode may be unknown.</div><div>     *</div><div>     * @return {@link PhoneConstants#LTE_ON_CDMA_UNKNOWN}, {@link PhoneConstants#LTE_ON_CDMA_FALSE}</div><div>     * or {@link PhoneConstants#LTE_ON_CDMA_TRUE}</div><div>     *</div><div>     * @hide</div><div>     */</div><div>    public int getLteOnCdmaMode() {</div><div>        return getLteOnCdmaMode(getDefaultSubscription());</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Return if the current radio is LTE on CDMA for Subscription. This</div><div>     * is a tri-state return value as for a period of time</div><div>     * the mode may be unknown.</div><div>     *</div><div>     * @param subId for which radio is LTE on CDMA is returned</div><div>     * @return {@link PhoneConstants#LTE_ON_CDMA_UNKNOWN}, {@link PhoneConstants#LTE_ON_CDMA_FALSE}</div><div>     * or {@link PhoneConstants#LTE_ON_CDMA_TRUE}</div><div>     *</div><div>     */</div><div>    /** {@hide} */</div><div>    public int getLteOnCdmaMode(int subId) {</div><div>        try {</div><div>            return getITelephony().getLteOnCdmaModeForSubscriber(subId);</div><div>        } catch (RemoteException ex) {</div><div>            // Assume no ICC card if remote exception which shouldn't happen</div><div>            return PhoneConstants.LTE_ON_CDMA_UNKNOWN;</div><div>        } catch (NullPointerException ex) {</div><div>            // This could happen before phone restarts due to crashing</div><div>            return PhoneConstants.LTE_ON_CDMA_UNKNOWN;</div><div>        }</div><div>    }</div><div><br/></div><div>    //</div><div>    //</div><div>    // Subscriber Info</div><div>    //</div><div>    //</div><div><br/></div><div>    /**</div><div>     * Returns the unique subscriber ID, for example, the IMSI for a GSM phone.</div><div>     * Return null if it is unavailable.</div><div>     * &lt;p&gt;</div><div>     * Requires Permission:</div><div>     *   {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}</div><div>     */</div><div>    public String getSubscriberId() {</div><div>        return getSubscriberId(getDefaultSubscription());</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns the unique subscriber ID, for example, the IMSI for a GSM phone</div><div>     * for a subscription.</div><div>     * Return null if it is unavailable.</div><div>     * &lt;p&gt;</div><div>     * Requires Permission:</div><div>     *   {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}</div><div>     *</div><div>     * @param subId whose subscriber id is returned</div><div>     */</div><div>    /** {@hide} */</div><div>    public String getSubscriberId(int subId) {</div><div>        try {</div><div>            return getSubscriberInfo().getSubscriberIdForSubscriber(subId);</div><div>        } catch (RemoteException ex) {</div><div>            return null;</div><div>        } catch (NullPointerException ex) {</div><div>            // This could happen before phone restarts due to crashing</div><div>            return null;</div><div>        }</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns the Group Identifier Level1 for a GSM phone.</div><div>     * Return null if it is unavailable.</div><div>     * &lt;p&gt;</div><div>     * Requires Permission:</div><div>     *   {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}</div><div>     */</div><div>    public String getGroupIdLevel1() {</div><div>        try {</div><div>            return getSubscriberInfo().getGroupIdLevel1();</div><div>        } catch (RemoteException ex) {</div><div>            return null;</div><div>        } catch (NullPointerException ex) {</div><div>            // This could happen before phone restarts due to crashing</div><div>            return null;</div><div>        }</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns the Group Identifier Level1 for a GSM phone for a particular subscription.</div><div>     * Return null if it is unavailable.</div><div>     * &lt;p&gt;</div><div>     * Requires Permission:</div><div>     *   {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}</div><div>     *</div><div>     * @param subscription whose subscriber id is returned</div><div>     */</div><div>    /** {@hide} */</div><div>    public String getGroupIdLevel1(int subId) {</div><div>        try {</div><div>            return getSubscriberInfo().getGroupIdLevel1ForSubscriber(subId);</div><div>        } catch (RemoteException ex) {</div><div>            return null;</div><div>        } catch (NullPointerException ex) {</div><div>            // This could happen before phone restarts due to crashing</div><div>            return null;</div><div>        }</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns the phone number string for line 1, for example, the MSISDN</div><div>     * for a GSM phone. Return null if it is unavailable.</div><div>     * &lt;p&gt;</div><div>     * Requires Permission:</div><div>     *   {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}</div><div>     */</div><div>    public String getLine1Number() {</div><div>        return getLine1NumberForSubscriber(getDefaultSubscription());</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns the phone number string for line 1, for example, the MSISDN</div><div>     * for a GSM phone for a particular subscription. Return null if it is unavailable.</div><div>     * &lt;p&gt;</div><div>     * Requires Permission:</div><div>     *   {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}</div><div>     *</div><div>     * @param subId whose phone number for line 1 is returned</div><div>     */</div><div>    /** {@hide} */</div><div>    public String getLine1NumberForSubscriber(int subId) {</div><div>        String number = null;</div><div>        try {</div><div>            number = getITelephony().getLine1NumberForDisplay(subId);</div><div>        } catch (RemoteException ex) {</div><div>        } catch (NullPointerException ex) {</div><div>        }</div><div>        if (number != null) {</div><div>            return number;</div><div>        }</div><div>        try {</div><div>            return getSubscriberInfo().getLine1NumberForSubscriber(subId);</div><div>        } catch (RemoteException ex) {</div><div>            return null;</div><div>        } catch (NullPointerException ex) {</div><div>            // This could happen before phone restarts due to crashing</div><div>            return null;</div><div>        }</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Set the line 1 phone number string and its alphatag for the current ICCID</div><div>     * for display purpose only, for example, displayed in Phone Status. It won't</div><div>     * change the actual MSISDN/MDN. To unset alphatag or number, pass in a null</div><div>     * value.</div><div>     *</div><div>     * &lt;p&gt;Requires that the calling app has carrier privileges.</div><div>     * @see #hasCarrierPrivileges</div><div>     *</div><div>     * @param alphaTag alpha-tagging of the dailing nubmer</div><div>     * @param number The dialing number</div><div>     * @return true if the operation was executed correctly.</div><div>     */</div><div>    public boolean setLine1NumberForDisplay(String alphaTag, String number) {</div><div>        return setLine1NumberForDisplayForSubscriber(getDefaultSubscription(), alphaTag, number);</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Set the line 1 phone number string and its alphatag for the current ICCID</div><div>     * for display purpose only, for example, displayed in Phone Status. It won't</div><div>     * change the actual MSISDN/MDN. To unset alphatag or number, pass in a null</div><div>     * value.</div><div>     *</div><div>     * &lt;p&gt;Requires that the calling app has carrier privileges.</div><div>     * @see #hasCarrierPrivileges</div><div>     *</div><div>     * @param subId the subscriber that the alphatag and dialing number belongs to.</div><div>     * @param alphaTag alpha-tagging of the dailing nubmer</div><div>     * @param number The dialing number</div><div>     * @return true if the operation was executed correctly.</div><div>     * @hide</div><div>     */</div><div>    public boolean setLine1NumberForDisplayForSubscriber(int subId, String alphaTag, String number) {</div><div>        try {</div><div>            return getITelephony().setLine1NumberForDisplayForSubscriber(subId, alphaTag, number);</div><div>        } catch (RemoteException ex) {</div><div>        } catch (NullPointerException ex) {</div><div>        }</div><div>        return false;</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns the alphabetic identifier associated with the line 1 number.</div><div>     * Return null if it is unavailable.</div><div>     * &lt;p&gt;</div><div>     * Requires Permission:</div><div>     *   {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}</div><div>     * @hide</div><div>     * nobody seems to call this.</div><div>     */</div><div>    public String getLine1AlphaTag() {</div><div>        return getLine1AlphaTagForSubscriber(getDefaultSubscription());</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns the alphabetic identifier associated with the line 1 number</div><div>     * for a subscription.</div><div>     * Return null if it is unavailable.</div><div>     * &lt;p&gt;</div><div>     * Requires Permission:</div><div>     *   {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}</div><div>     * @param subId whose alphabetic identifier associated with line 1 is returned</div><div>     * nobody seems to call this.</div><div>     */</div><div>    /** {@hide} */</div><div>    public String getLine1AlphaTagForSubscriber(int subId) {</div><div>        String alphaTag = null;</div><div>        try {</div><div>            alphaTag = getITelephony().getLine1AlphaTagForDisplay(subId);</div><div>        } catch (RemoteException ex) {</div><div>        } catch (NullPointerException ex) {</div><div>        }</div><div>        if (alphaTag != null) {</div><div>            return alphaTag;</div><div>        }</div><div>        try {</div><div>            return getSubscriberInfo().getLine1AlphaTagForSubscriber(subId);</div><div>        } catch (RemoteException ex) {</div><div>            return null;</div><div>        } catch (NullPointerException ex) {</div><div>            // This could happen before phone restarts due to crashing</div><div>            return null;</div><div>        }</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Return the set of subscriber IDs that should be considered as &quot;merged</div><div>     * together&quot; for data usage purposes. This is commonly {@code null} to</div><div>     * indicate no merging is required. Any returned subscribers are sorted in a</div><div>     * deterministic order.</div><div>     *</div><div>     * @hide</div><div>     */</div><div>    public @Nullable String[] getMergedSubscriberIds() {</div><div>        try {</div><div>            return getITelephony().getMergedSubscriberIds();</div><div>        } catch (RemoteException ex) {</div><div>        } catch (NullPointerException ex) {</div><div>        }</div><div>        return null;</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns the MSISDN string.</div><div>     * for a GSM phone. Return null if it is unavailable.</div><div>     * &lt;p&gt;</div><div>     * Requires Permission:</div><div>     *   {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}</div><div>     *</div><div>     * @hide</div><div>     */</div><div>    public String getMsisdn() {</div><div>        return getMsisdn(getDefaultSubscription());</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns the MSISDN string.</div><div>     * for a GSM phone. Return null if it is unavailable.</div><div>     * &lt;p&gt;</div><div>     * Requires Permission:</div><div>     *   {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}</div><div>     *</div><div>     * @param subId for which msisdn is returned</div><div>     */</div><div>    /** {@hide} */</div><div>    public String getMsisdn(int subId) {</div><div>        try {</div><div>            return getSubscriberInfo().getMsisdnForSubscriber(subId);</div><div>        } catch (RemoteException ex) {</div><div>            return null;</div><div>        } catch (NullPointerException ex) {</div><div>            // This could happen before phone restarts due to crashing</div><div>            return null;</div><div>        }</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns the voice mail number. Return null if it is unavailable.</div><div>     * &lt;p&gt;</div><div>     * Requires Permission:</div><div>     *   {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}</div><div>     */</div><div>    public String getVoiceMailNumber() {</div><div>        return getVoiceMailNumber(getDefaultSubscription());</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns the voice mail number for a subscription.</div><div>     * Return null if it is unavailable.</div><div>     * &lt;p&gt;</div><div>     * Requires Permission:</div><div>     *   {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}</div><div>     * @param subId whose voice mail number is returned</div><div>     */</div><div>    /** {@hide} */</div><div>    public String getVoiceMailNumber(int subId) {</div><div>        try {</div><div>            return getSubscriberInfo().getVoiceMailNumberForSubscriber(subId);</div><div>        } catch (RemoteException ex) {</div><div>            return null;</div><div>        } catch (NullPointerException ex) {</div><div>            // This could happen before phone restarts due to crashing</div><div>            return null;</div><div>        }</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns the complete voice mail number. Return null if it is unavailable.</div><div>     * &lt;p&gt;</div><div>     * Requires Permission:</div><div>     *   {@link android.Manifest.permission#CALL_PRIVILEGED CALL_PRIVILEGED}</div><div>     *</div><div>     * @hide</div><div>     */</div><div>    public String getCompleteVoiceMailNumber() {</div><div>        return getCompleteVoiceMailNumber(getDefaultSubscription());</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns the complete voice mail number. Return null if it is unavailable.</div><div>     * &lt;p&gt;</div><div>     * Requires Permission:</div><div>     *   {@link android.Manifest.permission#CALL_PRIVILEGED CALL_PRIVILEGED}</div><div>     *</div><div>     * @param subId</div><div>     */</div><div>    /** {@hide} */</div><div>    public String getCompleteVoiceMailNumber(int subId) {</div><div>        try {</div><div>            return getSubscriberInfo().getCompleteVoiceMailNumberForSubscriber(subId);</div><div>        } catch (RemoteException ex) {</div><div>            return null;</div><div>        } catch (NullPointerException ex) {</div><div>            // This could happen before phone restarts due to crashing</div><div>            return null;</div><div>        }</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Sets the voice mail number.</div><div>     *</div><div>     * &lt;p&gt;Requires that the calling app has carrier privileges.</div><div>     * @see #hasCarrierPrivileges</div><div>     *</div><div>     * @param alphaTag The alpha tag to display.</div><div>     * @param number The voicemail number.</div><div>     */</div><div>    public boolean setVoiceMailNumber(String alphaTag, String number) {</div><div>        return setVoiceMailNumber(getDefaultSubscription(), alphaTag, number);</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Sets the voicemail number for the given subscriber.</div><div>     *</div><div>     * &lt;p&gt;Requires that the calling app has carrier privileges.</div><div>     * @see #hasCarrierPrivileges</div><div>     *</div><div>     * @param subId The subscription id.</div><div>     * @param alphaTag The alpha tag to display.</div><div>     * @param number The voicemail number.</div><div>     */</div><div>    /** {@hide} */</div><div>    public boolean setVoiceMailNumber(int subId, String alphaTag, String number) {</div><div>        try {</div><div>            return getITelephony().setVoiceMailNumber(subId, alphaTag, number);</div><div>        } catch (RemoteException ex) {</div><div>        } catch (NullPointerException ex) {</div><div>        }</div><div>        return false;</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns the voice mail count. Return 0 if unavailable.</div><div>     * &lt;p&gt;</div><div>     * Requires Permission:</div><div>     *   {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}</div><div>     * @hide</div><div>     */</div><div>    public int getVoiceMessageCount() {</div><div>        return getVoiceMessageCount(getDefaultSubscription());</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns the voice mail count for a subscription. Return 0 if unavailable.</div><div>     * &lt;p&gt;</div><div>     * Requires Permission:</div><div>     *   {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}</div><div>     * @param subId whose voice message count is returned</div><div>     */</div><div>    /** {@hide} */</div><div>    public int getVoiceMessageCount(int subId) {</div><div>        try {</div><div>            return getITelephony().getVoiceMessageCountForSubscriber(subId);</div><div>        } catch (RemoteException ex) {</div><div>            return 0;</div><div>        } catch (NullPointerException ex) {</div><div>            // This could happen before phone restarts due to crashing</div><div>            return 0;</div><div>        }</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Retrieves the alphabetic identifier associated with the voice</div><div>     * mail number.</div><div>     * &lt;p&gt;</div><div>     * Requires Permission:</div><div>     *   {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}</div><div>     */</div><div>    public String getVoiceMailAlphaTag() {</div><div>        return getVoiceMailAlphaTag(getDefaultSubscription());</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Retrieves the alphabetic identifier associated with the voice</div><div>     * mail number for a subscription.</div><div>     * &lt;p&gt;</div><div>     * Requires Permission:</div><div>     * {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}</div><div>     * @param subId whose alphabetic identifier associated with the</div><div>     * voice mail number is returned</div><div>     */</div><div>    /** {@hide} */</div><div>    public String getVoiceMailAlphaTag(int subId) {</div><div>        try {</div><div>            return getSubscriberInfo().getVoiceMailAlphaTagForSubscriber(subId);</div><div>        } catch (RemoteException ex) {</div><div>            return null;</div><div>        } catch (NullPointerException ex) {</div><div>            // This could happen before phone restarts due to crashing</div><div>            return null;</div><div>        }</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns the IMS private user identity (IMPI) that was loaded from the ISIM.</div><div>     * @return the IMPI, or null if not present or not loaded</div><div>     * @hide</div><div>     */</div><div>    public String getIsimImpi() {</div><div>        try {</div><div>            return getSubscriberInfo().getIsimImpi();</div><div>        } catch (RemoteException ex) {</div><div>            return null;</div><div>        } catch (NullPointerException ex) {</div><div>            // This could happen before phone restarts due to crashing</div><div>            return null;</div><div>        }</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns the IMS home network domain name that was loaded from the ISIM.</div><div>     * @return the IMS domain name, or null if not present or not loaded</div><div>     * @hide</div><div>     */</div><div>    public String getIsimDomain() {</div><div>        try {</div><div>            return getSubscriberInfo().getIsimDomain();</div><div>        } catch (RemoteException ex) {</div><div>            return null;</div><div>        } catch (NullPointerException ex) {</div><div>            // This could happen before phone restarts due to crashing</div><div>            return null;</div><div>        }</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns the IMS public user identities (IMPU) that were loaded from the ISIM.</div><div>     * @return an array of IMPU strings, with one IMPU per string, or null if</div><div>     *      not present or not loaded</div><div>     * @hide</div><div>     */</div><div>    public String[] getIsimImpu() {</div><div>        try {</div><div>            return getSubscriberInfo().getIsimImpu();</div><div>        } catch (RemoteException ex) {</div><div>            return null;</div><div>        } catch (NullPointerException ex) {</div><div>            // This could happen before phone restarts due to crashing</div><div>            return null;</div><div>        }</div><div>    }</div><div><br/></div><div>   /**</div><div>    * @hide</div><div>    */</div><div>    private IPhoneSubInfo getSubscriberInfo() {</div><div>        // get it each time because that process crashes a lot</div><div>        return IPhoneSubInfo.Stub.asInterface(ServiceManager.getService(&quot;iphonesubinfo&quot;));</div><div>    }</div><div><br/></div><div>    /** Device call state: No activity. */</div><div>    public static final int CALL_STATE_IDLE = 0;</div><div>    /** Device call state: Ringing. A new call arrived and is</div><div>     *  ringing or waiting. In the latter case, another call is</div><div>     *  already active. */</div><div>    public static final int CALL_STATE_RINGING = 1;</div><div>    /** Device call state: Off-hook. At least one call exists</div><div>      * that is dialing, active, or on hold, and no calls are ringing</div><div>      * or waiting. */</div><div>    public static final int CALL_STATE_OFFHOOK = 2;</div><div><br/></div><div>    /**</div><div>     * Returns a constant indicating the call state (cellular) on the device.</div><div>     */</div><div>    public int getCallState() {</div><div>        try {</div><div>            return getTelecomService().getCallState();</div><div>        } catch (RemoteException | NullPointerException e) {</div><div>            return CALL_STATE_IDLE;</div><div>        }</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns a constant indicating the call state (cellular) on the device</div><div>     * for a subscription.</div><div>     *</div><div>     * @param subId whose call state is returned</div><div>     */</div><div>    /** {@hide} */</div><div>    public int getCallState(int subId) {</div><div>        try {</div><div>            return getITelephony().getCallStateForSubscriber(subId);</div><div>        } catch (RemoteException ex) {</div><div>            // the phone process is restarting.</div><div>            return CALL_STATE_IDLE;</div><div>        } catch (NullPointerException ex) {</div><div>          // the phone process is restarting.</div><div>          return CALL_STATE_IDLE;</div><div>      }</div><div>    }</div><div><br/></div><div>    /** Data connection activity: No traffic. */</div><div>    public static final int DATA_ACTIVITY_NONE = 0x00000000;</div><div>    /** Data connection activity: Currently receiving IP PPP traffic. */</div><div>    public static final int DATA_ACTIVITY_IN = 0x00000001;</div><div>    /** Data connection activity: Currently sending IP PPP traffic. */</div><div>    public static final int DATA_ACTIVITY_OUT = 0x00000002;</div><div>    /** Data connection activity: Currently both sending and receiving</div><div>     *  IP PPP traffic. */</div><div>    public static final int DATA_ACTIVITY_INOUT = DATA_ACTIVITY_IN | DATA_ACTIVITY_OUT;</div><div>    /**</div><div>     * Data connection is active, but physical link is down</div><div>     */</div><div>    public static final int DATA_ACTIVITY_DORMANT = 0x00000004;</div><div><br/></div><div>    /**</div><div>     * Returns a constant indicating the type of activity on a data connection</div><div>     * (cellular).</div><div>     *</div><div>     * @see #DATA_ACTIVITY_NONE</div><div>     * @see #DATA_ACTIVITY_IN</div><div>     * @see #DATA_ACTIVITY_OUT</div><div>     * @see #DATA_ACTIVITY_INOUT</div><div>     * @see #DATA_ACTIVITY_DORMANT</div><div>     */</div><div>    public int getDataActivity() {</div><div>        try {</div><div>            return getITelephony().getDataActivity();</div><div>        } catch (RemoteException ex) {</div><div>            // the phone process is restarting.</div><div>            return DATA_ACTIVITY_NONE;</div><div>        } catch (NullPointerException ex) {</div><div>          // the phone process is restarting.</div><div>          return DATA_ACTIVITY_NONE;</div><div>        }</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns a constant indicating the type of activity on a data connection</div><div>     * (cellular).</div><div>     *</div><div>     * @see #DATA_ACTIVITY_NONE</div><div>     * @see #DATA_ACTIVITY_IN</div><div>     * @see #DATA_ACTIVITY_OUT</div><div>     * @see #DATA_ACTIVITY_INOUT</div><div>     * @see #DATA_ACTIVITY_DORMANT</div><div>     *</div><div>     * @param subId for which network type is returned</div><div>     */</div><div>    /** {@hide} */</div><div>    public int getDataActivity(int subId) {</div><div>        try {</div><div>            ITelephony telephony = getITelephony();</div><div>            if (telephony != null) {</div><div>                return telephony.getDataActivityForSubscriber(subId);</div><div>            } else {</div><div>                // This can happen when the ITelephony interface is not up yet.</div><div>                return DATA_ACTIVITY_NONE;</div><div>            }</div><div>        } catch (RemoteException ex) {</div><div>            // the phone process is restarting.</div><div>            return DATA_ACTIVITY_NONE;</div><div>        } catch (NullPointerException ex) {</div><div>          // the phone process is restarting.</div><div>          return DATA_ACTIVITY_NONE;</div><div>        }</div><div>    }</div><div><br/></div><div>    /** Data connection state: Unknown.  Used before we know the state.</div><div>     * @hide</div><div>     */</div><div>    public static final int DATA_UNKNOWN        = -1;</div><div>    /** Data connection state: Disconnected. IP traffic not available. */</div><div>    public static final int DATA_DISCONNECTED   = 0;</div><div>    /** Data connection state: Currently setting up a data connection. */</div><div>    public static final int DATA_CONNECTING     = 1;</div><div>    /** Data connection state: Connected. IP traffic should be available. */</div><div>    public static final int DATA_CONNECTED      = 2;</div><div>    /** Data connection state: Suspended. The connection is up, but IP</div><div>     * traffic is temporarily unavailable. For example, in a 2G network,</div><div>     * data activity may be suspended when a voice call arrives. */</div><div>    public static final int DATA_SUSPENDED      = 3;</div><div><br/></div><div>    /**</div><div>     * Returns a constant indicating the current data connection state</div><div>     * (cellular).</div><div>     *</div><div>     * @see #DATA_DISCONNECTED</div><div>     * @see #DATA_CONNECTING</div><div>     * @see #DATA_CONNECTED</div><div>     * @see #DATA_SUSPENDED</div><div>     */</div><div>    public int getDataState() {</div><div>        try {</div><div>            return getITelephony().getDataState();</div><div>        } catch (RemoteException ex) {</div><div>            // the phone process is restarting.</div><div>            return DATA_DISCONNECTED;</div><div>        } catch (NullPointerException ex) {</div><div>            return DATA_DISCONNECTED;</div><div>        }</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns a constant indicating the current data connection state</div><div>     * (cellular).</div><div>     *</div><div>     * @see #DATA_DISCONNECTED</div><div>     * @see #DATA_CONNECTING</div><div>     * @see #DATA_CONNECTED</div><div>     * @see #DATA_SUSPENDED</div><div>     *</div><div>     * @param subId for which network type is returned</div><div>     */</div><div>    /** {@hide} */</div><div>    public int getDataState(int subId) {</div><div>        try {</div><div>            ITelephony telephony = getITelephony();</div><div>            if (telephony != null) {</div><div>                return telephony.getDataStateForSubscriber(subId);</div><div>            } else {</div><div>                // This can happen when the ITelephony interface is not up yet.</div><div>                return DATA_DISCONNECTED;</div><div>            }</div><div>        } catch (RemoteException ex) {</div><div>            // the phone process is restarting.</div><div>            return DATA_DISCONNECTED;</div><div>        } catch (NullPointerException ex) {</div><div>            return DATA_DISCONNECTED;</div><div>        }</div><div>    }</div><div><br/></div><div>   /**</div><div>    * @hide</div><div>    */</div><div>    private ITelephony getITelephony() {</div><div>        return ITelephony.Stub.asInterface(ServiceManager.getService(Context.TELEPHONY_SERVICE));</div><div>    }</div><div><br/></div><div>    /**</div><div>    * @hide</div><div>    */</div><div>    private ITelecomService getTelecomService() {</div><div>        return ITelecomService.Stub.asInterface(ServiceManager.getService(Context.TELECOM_SERVICE));</div><div>    }</div><div><br/></div><div>    //</div><div>    //</div><div>    // PhoneStateListener</div><div>    //</div><div>    //</div><div><br/></div><div>    /**</div><div>     * Registers a listener object to receive notification of changes</div><div>     * in specified telephony states.</div><div>     * &lt;p&gt;</div><div>     * To register a listener, pass a {@link PhoneStateListener}</div><div>     * and specify at least one telephony state of interest in</div><div>     * the events argument.</div><div>     *</div><div>     * At registration, and when a specified telephony state</div><div>     * changes, the telephony manager invokes the appropriate</div><div>     * callback method on the listener object and passes the</div><div>     * current (updated) values.</div><div>     * &lt;p&gt;</div><div>     * To unregister a listener, pass the listener object and set the</div><div>     * events argument to</div><div>     * {@link PhoneStateListener#LISTEN_NONE LISTEN_NONE} (0).</div><div>     *</div><div>     * @param listener The {@link PhoneStateListener} object to register</div><div>     *                 (or unregister)</div><div>     * @param events The telephony state(s) of interest to the listener,</div><div>     *               as a bitwise-OR combination of {@link PhoneStateListener}</div><div>     *               LISTEN_ flags.</div><div>     */</div><div>    public void listen(PhoneStateListener listener, int events) {</div><div>        String pkgForDebug = mContext != null ? mContext.getPackageName() : &quot;&lt;unknown&gt;&quot;;</div><div>        try {</div><div>            Boolean notifyNow = (getITelephony() != null);</div><div>            sRegistry.listenForSubscriber(listener.mSubId, pkgForDebug, listener.callback, events, notifyNow);</div><div>        } catch (RemoteException ex) {</div><div>            // system process dead</div><div>        } catch (NullPointerException ex) {</div><div>            // system process dead</div><div>        }</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns the CDMA ERI icon index to display</div><div>     *</div><div>     * @hide</div><div>     */</div><div>    public int getCdmaEriIconIndex() {</div><div>        return getCdmaEriIconIndex(getDefaultSubscription());</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns the CDMA ERI icon index to display for a subscription</div><div>     */</div><div>    /** {@hide} */</div><div>    public int getCdmaEriIconIndex(int subId) {</div><div>        try {</div><div>            return getITelephony().getCdmaEriIconIndexForSubscriber(subId);</div><div>        } catch (RemoteException ex) {</div><div>            // the phone process is restarting.</div><div>            return -1;</div><div>        } catch (NullPointerException ex) {</div><div>            return -1;</div><div>        }</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns the CDMA ERI icon mode,</div><div>     * 0 - ON</div><div>     * 1 - FLASHING</div><div>     *</div><div>     * @hide</div><div>     */</div><div>    public int getCdmaEriIconMode() {</div><div>        return getCdmaEriIconMode(getDefaultSubscription());</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns the CDMA ERI icon mode for a subscription.</div><div>     * 0 - ON</div><div>     * 1 - FLASHING</div><div>     */</div><div>    /** {@hide} */</div><div>    public int getCdmaEriIconMode(int subId) {</div><div>        try {</div><div>            return getITelephony().getCdmaEriIconModeForSubscriber(subId);</div><div>        } catch (RemoteException ex) {</div><div>            // the phone process is restarting.</div><div>            return -1;</div><div>        } catch (NullPointerException ex) {</div><div>            return -1;</div><div>        }</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns the CDMA ERI text,</div><div>     *</div><div>     * @hide</div><div>     */</div><div>    public String getCdmaEriText() {</div><div>        return getCdmaEriText(getDefaultSubscription());</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns the CDMA ERI text, of a subscription</div><div>     *</div><div>     */</div><div>    /** {@hide} */</div><div>    public String getCdmaEriText(int subId) {</div><div>        try {</div><div>            return getITelephony().getCdmaEriTextForSubscriber(subId);</div><div>        } catch (RemoteException ex) {</div><div>            // the phone process is restarting.</div><div>            return null;</div><div>        } catch (NullPointerException ex) {</div><div>            return null;</div><div>        }</div><div>    }</div><div><br/></div><div>    /**</div><div>     * @return true if the current device is &quot;voice capable&quot;.</div><div>     * &lt;p&gt;</div><div>     * &quot;Voice capable&quot; means that this device supports circuit-switched</div><div>     * (i.e. voice) phone calls over the telephony network, and is allowed</div><div>     * to display the in-call UI while a cellular voice call is active.</div><div>     * This will be false on &quot;data only&quot; devices which can't make voice</div><div>     * calls and don't support any in-call UI.</div><div>     * &lt;p&gt;</div><div>     * Note: the meaning of this flag is subtly different from the</div><div>     * PackageManager.FEATURE_TELEPHONY system feature, which is available</div><div>     * on any device with a telephony radio, even if the device is</div><div>     * data-only.</div><div>     */</div><div>    public boolean isVoiceCapable() {</div><div>        if (mContext == null) return true;</div><div>        return mContext.getResources().getBoolean(</div><div>                com.android.internal.R.bool.config_voice_capable);</div><div>    }</div><div><br/></div><div>    /**</div><div>     * @return true if the current device supports sms service.</div><div>     * &lt;p&gt;</div><div>     * If true, this means that the device supports both sending and</div><div>     * receiving sms via the telephony network.</div><div>     * &lt;p&gt;</div><div>     * Note: Voicemail waiting sms, cell broadcasting sms, and MMS are</div><div>     *       disabled when device doesn't support sms.</div><div>     */</div><div>    public boolean isSmsCapable() {</div><div>        if (mContext == null) return true;</div><div>        return mContext.getResources().getBoolean(</div><div>                com.android.internal.R.bool.config_sms_capable);</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns all observed cell information from all radios on the</div><div>     * device including the primary and neighboring cells. This does</div><div>     * not cause or change the rate of PhoneStateListner#onCellInfoChanged.</div><div>     *&lt;p&gt;</div><div>     * The list can include one or more of {@link android.telephony.CellInfoGsm CellInfoGsm},</div><div>     * {@link android.telephony.CellInfoCdma CellInfoCdma},</div><div>     * {@link android.telephony.CellInfoLte CellInfoLte} and</div><div>     * {@link android.telephony.CellInfoWcdma CellInfoCdma} in any combination.</div><div>     * Specifically on devices with multiple radios it is typical to see instances of</div><div>     * one or more of any these in the list. In addition 0, 1 or more CellInfo</div><div>     * objects may return isRegistered() true.</div><div>     *&lt;p&gt;</div><div>     * This is preferred over using getCellLocation although for older</div><div>     * devices this may return null in which case getCellLocation should</div><div>     * be called.</div><div>     *&lt;p&gt;</div><div>     * @return List of CellInfo or null if info unavailable.</div><div>     *</div><div>     * &lt;p&gt;Requires Permission: {@link android.Manifest.permission#ACCESS_COARSE_LOCATION}</div><div>     */</div><div>    public List&lt;CellInfo&gt; getAllCellInfo() {</div><div>        try {</div><div>            return getITelephony().getAllCellInfo();</div><div>        } catch (RemoteException ex) {</div><div>            return null;</div><div>        } catch (NullPointerException ex) {</div><div>            return null;</div><div>        }</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Sets the minimum time in milli-seconds between {@link PhoneStateListener#onCellInfoChanged</div><div>     * PhoneStateListener.onCellInfoChanged} will be invoked.</div><div>     *&lt;p&gt;</div><div>     * The default, 0, means invoke onCellInfoChanged when any of the reported</div><div>     * information changes. Setting the value to INT_MAX(0x7fffffff) means never issue</div><div>     * A onCellInfoChanged.</div><div>     *&lt;p&gt;</div><div>     * @param rateInMillis the rate</div><div>     *</div><div>     * @hide</div><div>     */</div><div>    public void setCellInfoListRate(int rateInMillis) {</div><div>        try {</div><div>            getITelephony().setCellInfoListRate(rateInMillis);</div><div>        } catch (RemoteException ex) {</div><div>        } catch (NullPointerException ex) {</div><div>        }</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns the MMS user agent.</div><div>     */</div><div>    public String getMmsUserAgent() {</div><div>        if (mContext == null) return null;</div><div>        return mContext.getResources().getString(</div><div>                com.android.internal.R.string.config_mms_user_agent);</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns the MMS user agent profile URL.</div><div>     */</div><div>    public String getMmsUAProfUrl() {</div><div>        if (mContext == null) return null;</div><div>        return mContext.getResources().getString(</div><div>                com.android.internal.R.string.config_mms_user_agent_profile_url);</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Opens a logical channel to the ICC card.</div><div>     *</div><div>     * Input parameters equivalent to TS 27.007 AT+CCHO command.</div><div>     *</div><div>     * &lt;p&gt;Requires Permission:</div><div>     *   {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE}</div><div>     * Or the calling app has carrier privileges. @see #hasCarrierPrivileges</div><div>     *</div><div>     * @param AID Application id. See ETSI 102.221 and 101.220.</div><div>     * @return an IccOpenLogicalChannelResponse object.</div><div>     */</div><div>    public IccOpenLogicalChannelResponse iccOpenLogicalChannel(String AID) {</div><div>        try {</div><div>            return getITelephony().iccOpenLogicalChannel(AID);</div><div>        } catch (RemoteException ex) {</div><div>        } catch (NullPointerException ex) {</div><div>        }</div><div>        return null;</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Closes a previously opened logical channel to the ICC card.</div><div>     *</div><div>     * Input parameters equivalent to TS 27.007 AT+CCHC command.</div><div>     *</div><div>     * &lt;p&gt;Requires Permission:</div><div>     *   {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE}</div><div>     * Or the calling app has carrier privileges. @see #hasCarrierPrivileges</div><div>     *</div><div>     * @param channel is the channel id to be closed as retruned by a successful</div><div>     *            iccOpenLogicalChannel.</div><div>     * @return true if the channel was closed successfully.</div><div>     */</div><div>    public boolean iccCloseLogicalChannel(int channel) {</div><div>        try {</div><div>            return getITelephony().iccCloseLogicalChannel(channel);</div><div>        } catch (RemoteException ex) {</div><div>        } catch (NullPointerException ex) {</div><div>        }</div><div>        return false;</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Transmit an APDU to the ICC card over a logical channel.</div><div>     *</div><div>     * Input parameters equivalent to TS 27.007 AT+CGLA command.</div><div>     *</div><div>     * &lt;p&gt;Requires Permission:</div><div>     *   {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE}</div><div>     * Or the calling app has carrier privileges. @see #hasCarrierPrivileges</div><div>     *</div><div>     * @param channel is the channel id to be closed as returned by a successful</div><div>     *            iccOpenLogicalChannel.</div><div>     * @param cla Class of the APDU command.</div><div>     * @param instruction Instruction of the APDU command.</div><div>     * @param p1 P1 value of the APDU command.</div><div>     * @param p2 P2 value of the APDU command.</div><div>     * @param p3 P3 value of the APDU command. If p3 is negative a 4 byte APDU</div><div>     *            is sent to the SIM.</div><div>     * @param data Data to be sent with the APDU.</div><div>     * @return The APDU response from the ICC card with the status appended at</div><div>     *            the end.</div><div>     */</div><div>    public String iccTransmitApduLogicalChannel(int channel, int cla,</div><div>            int instruction, int p1, int p2, int p3, String data) {</div><div>        try {</div><div>            return getITelephony().iccTransmitApduLogicalChannel(channel, cla,</div><div>                    instruction, p1, p2, p3, data);</div><div>        } catch (RemoteException ex) {</div><div>        } catch (NullPointerException ex) {</div><div>        }</div><div>        return &quot;&quot;;</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Transmit an APDU to the ICC card over the basic channel.</div><div>     *</div><div>     * Input parameters equivalent to TS 27.007 AT+CSIM command.</div><div>     *</div><div>     * &lt;p&gt;Requires Permission:</div><div>     *   {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE}</div><div>     * Or the calling app has carrier privileges. @see #hasCarrierPrivileges</div><div>     *</div><div>     * @param cla Class of the APDU command.</div><div>     * @param instruction Instruction of the APDU command.</div><div>     * @param p1 P1 value of the APDU command.</div><div>     * @param p2 P2 value of the APDU command.</div><div>     * @param p3 P3 value of the APDU command. If p3 is negative a 4 byte APDU</div><div>     *            is sent to the SIM.</div><div>     * @param data Data to be sent with the APDU.</div><div>     * @return The APDU response from the ICC card with the status appended at</div><div>     *            the end.</div><div>     */</div><div>    public String iccTransmitApduBasicChannel(int cla,</div><div>            int instruction, int p1, int p2, int p3, String data) {</div><div>        try {</div><div>            return getITelephony().iccTransmitApduBasicChannel(cla,</div><div>                    instruction, p1, p2, p3, data);</div><div>        } catch (RemoteException ex) {</div><div>        } catch (NullPointerException ex) {</div><div>        }</div><div>        return &quot;&quot;;</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns the response APDU for a command APDU sent through SIM_IO.</div><div>     *</div><div>     * &lt;p&gt;Requires Permission:</div><div>     *   {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE}</div><div>     * Or the calling app has carrier privileges. @see #hasCarrierPrivileges</div><div>     *</div><div>     * @param fileID</div><div>     * @param command</div><div>     * @param p1 P1 value of the APDU command.</div><div>     * @param p2 P2 value of the APDU command.</div><div>     * @param p3 P3 value of the APDU command.</div><div>     * @param filePath</div><div>     * @return The APDU response.</div><div>     */</div><div>    public byte[] iccExchangeSimIO(int fileID, int command, int p1, int p2, int p3,</div><div>            String filePath) {</div><div>        try {</div><div>            return getITelephony().iccExchangeSimIO(fileID, command, p1, p2,</div><div>                p3, filePath);</div><div>        } catch (RemoteException ex) {</div><div>        } catch (NullPointerException ex) {</div><div>        }</div><div>        return null;</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Send ENVELOPE to the SIM and return the response.</div><div>     *</div><div>     * &lt;p&gt;Requires Permission:</div><div>     *   {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE}</div><div>     * Or the calling app has carrier privileges. @see #hasCarrierPrivileges</div><div>     *</div><div>     * @param content String containing SAT/USAT response in hexadecimal</div><div>     *                format starting with command tag. See TS 102 223 for</div><div>     *                details.</div><div>     * @return The APDU response from the ICC card in hexadecimal format</div><div>     *         with the last 4 bytes being the status word. If the command fails,</div><div>     *         returns an empty string.</div><div>     */</div><div>    public String sendEnvelopeWithStatus(String content) {</div><div>        try {</div><div>            return getITelephony().sendEnvelopeWithStatus(content);</div><div>        } catch (RemoteException ex) {</div><div>        } catch (NullPointerException ex) {</div><div>        }</div><div>        return &quot;&quot;;</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Read one of the NV items defined in com.android.internal.telephony.RadioNVItems.</div><div>     * Used for device configuration by some CDMA operators.</div><div>     * &lt;p&gt;</div><div>     * Requires Permission:</div><div>     *   {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE}</div><div>     * Or the calling app has carrier privileges. @see #hasCarrierPrivileges</div><div>     *</div><div>     * @param itemID the ID of the item to read.</div><div>     * @return the NV item as a String, or null on any failure.</div><div>     *</div><div>     * @hide</div><div>     */</div><div>    public String nvReadItem(int itemID) {</div><div>        try {</div><div>            return getITelephony().nvReadItem(itemID);</div><div>        } catch (RemoteException ex) {</div><div>            Rlog.e(TAG, &quot;nvReadItem RemoteException&quot;, ex);</div><div>        } catch (NullPointerException ex) {</div><div>            Rlog.e(TAG, &quot;nvReadItem NPE&quot;, ex);</div><div>        }</div><div>        return &quot;&quot;;</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Write one of the NV items defined in com.android.internal.telephony.RadioNVItems.</div><div>     * Used for device configuration by some CDMA operators.</div><div>     * &lt;p&gt;</div><div>     * Requires Permission:</div><div>     *   {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE}</div><div>     * Or the calling app has carrier privileges. @see #hasCarrierPrivileges</div><div>     *</div><div>     * @param itemID the ID of the item to read.</div><div>     * @param itemValue the value to write, as a String.</div><div>     * @return true on success; false on any failure.</div><div>     *</div><div>     * @hide</div><div>     */</div><div>    public boolean nvWriteItem(int itemID, String itemValue) {</div><div>        try {</div><div>            return getITelephony().nvWriteItem(itemID, itemValue);</div><div>        } catch (RemoteException ex) {</div><div>            Rlog.e(TAG, &quot;nvWriteItem RemoteException&quot;, ex);</div><div>        } catch (NullPointerException ex) {</div><div>            Rlog.e(TAG, &quot;nvWriteItem NPE&quot;, ex);</div><div>        }</div><div>        return false;</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Update the CDMA Preferred Roaming List (PRL) in the radio NV storage.</div><div>     * Used for device configuration by some CDMA operators.</div><div>     * &lt;p&gt;</div><div>     * Requires Permission:</div><div>     *   {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE}</div><div>     * Or the calling app has carrier privileges. @see #hasCarrierPrivileges</div><div>     *</div><div>     * @param preferredRoamingList byte array containing the new PRL.</div><div>     * @return true on success; false on any failure.</div><div>     *</div><div>     * @hide</div><div>     */</div><div>    public boolean nvWriteCdmaPrl(byte[] preferredRoamingList) {</div><div>        try {</div><div>            return getITelephony().nvWriteCdmaPrl(preferredRoamingList);</div><div>        } catch (RemoteException ex) {</div><div>            Rlog.e(TAG, &quot;nvWriteCdmaPrl RemoteException&quot;, ex);</div><div>        } catch (NullPointerException ex) {</div><div>            Rlog.e(TAG, &quot;nvWriteCdmaPrl NPE&quot;, ex);</div><div>        }</div><div>        return false;</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Perform the specified type of NV config reset. The radio will be taken offline</div><div>     * and the device must be rebooted after the operation. Used for device</div><div>     * configuration by some CDMA operators.</div><div>     * &lt;p&gt;</div><div>     * Requires Permission:</div><div>     *   {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE}</div><div>     * Or the calling app has carrier privileges. @see #hasCarrierPrivileges</div><div>     *</div><div>     * @param resetType reset type: 1: reload NV reset, 2: erase NV reset, 3: factory NV reset</div><div>     * @return true on success; false on any failure.</div><div>     *</div><div>     * @hide</div><div>     */</div><div>    public boolean nvResetConfig(int resetType) {</div><div>        try {</div><div>            return getITelephony().nvResetConfig(resetType);</div><div>        } catch (RemoteException ex) {</div><div>            Rlog.e(TAG, &quot;nvResetConfig RemoteException&quot;, ex);</div><div>        } catch (NullPointerException ex) {</div><div>            Rlog.e(TAG, &quot;nvResetConfig NPE&quot;, ex);</div><div>        }</div><div>        return false;</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns Default subscription.</div><div>     */</div><div>    private static int getDefaultSubscription() {</div><div>        return SubscriptionManager.getDefaultSubId();</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns Default phone.</div><div>     */</div><div>    private static int getDefaultPhone() {</div><div>        return SubscriptionManager.getPhoneId(SubscriptionManager.getDefaultSubId());</div><div>    }</div><div><br/></div><div>    /** {@hide} */</div><div>    public int getDefaultSim() {</div><div>        return SubscriptionManager.getSlotId(SubscriptionManager.getDefaultSubId());</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Sets the telephony property with the value specified.</div><div>     *</div><div>     * @hide</div><div>     */</div><div>    public static void setTelephonyProperty(int phoneId, String property, String value) {</div><div>        String propVal = &quot;&quot;;</div><div>        String p[] = null;</div><div>        String prop = SystemProperties.get(property);</div><div><br/></div><div>        if (value == null) {</div><div>            value = &quot;&quot;;</div><div>        }</div><div><br/></div><div>        if (prop != null) {</div><div>            p = prop.split(&quot;,&quot;);</div><div>        }</div><div><br/></div><div>        if (!SubscriptionManager.isValidPhoneId(phoneId)) {</div><div>            Rlog.d(TAG, &quot;setTelephonyProperty: invalid phoneId=&quot; + phoneId +</div><div>                    &quot; property=&quot; + property + &quot; value: &quot; + value + &quot; prop=&quot; + prop);</div><div>            return;</div><div>        }</div><div><br/></div><div>        for (int i = 0; i &lt; phoneId; i++) {</div><div>            String str = &quot;&quot;;</div><div>            if ((p != null) &amp;&amp; (i &lt; p.length)) {</div><div>                str = p[i];</div><div>            }</div><div>            propVal = propVal + str + &quot;,&quot;;</div><div>        }</div><div><br/></div><div>        propVal = propVal + value;</div><div>        if (p != null) {</div><div>            for (int i = phoneId + 1; i &lt; p.length; i++) {</div><div>                propVal = propVal + &quot;,&quot; + p[i];</div><div>            }</div><div>        }</div><div><br/></div><div>        if (property.length() &gt; SystemProperties.PROP_NAME_MAX</div><div>                || propVal.length() &gt; SystemProperties.PROP_VALUE_MAX) {</div><div>            Rlog.d(TAG, &quot;setTelephonyProperty: property to long phoneId=&quot; + phoneId +</div><div>                    &quot; property=&quot; + property + &quot; value: &quot; + value + &quot; propVal=&quot; + propVal);</div><div>            return;</div><div>        }</div><div><br/></div><div>        Rlog.d(TAG, &quot;setTelephonyProperty: success phoneId=&quot; + phoneId +</div><div>                &quot; property=&quot; + property + &quot; value: &quot; + value + &quot; propVal=&quot; + propVal);</div><div>        SystemProperties.set(property, propVal);</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Convenience function for retrieving a value from the secure settings</div><div>     * value list as an integer.  Note that internally setting values are</div><div>     * always stored as strings; this function converts the string to an</div><div>     * integer for you.</div><div>     * &lt;p&gt;</div><div>     * This version does not take a default value.  If the setting has not</div><div>     * been set, or the string value is not a number,</div><div>     * it throws {@link SettingNotFoundException}.</div><div>     *</div><div>     * @param cr The ContentResolver to access.</div><div>     * @param name The name of the setting to retrieve.</div><div>     * @param index The index of the list</div><div>     *</div><div>     * @throws SettingNotFoundException Thrown if a setting by the given</div><div>     * name can't be found or the setting value is not an integer.</div><div>     *</div><div>     * @return The value at the given index of settings.</div><div>     * @hide</div><div>     */</div><div>    public static int getIntAtIndex(android.content.ContentResolver cr,</div><div>            String name, int index)</div><div>            throws android.provider.Settings.SettingNotFoundException {</div><div>        String v = android.provider.Settings.Global.getString(cr, name);</div><div>        if (v != null) {</div><div>            String valArray[] = v.split(&quot;,&quot;);</div><div>            if ((index &gt;= 0) &amp;&amp; (index &lt; valArray.length) &amp;&amp; (valArray[index] != null)) {</div><div>                try {</div><div>                    return Integer.parseInt(valArray[index]);</div><div>                } catch (NumberFormatException e) {</div><div>                    //Log.e(TAG, &quot;Exception while parsing Integer: &quot;, e);</div><div>                }</div><div>            }</div><div>        }</div><div>        throw new android.provider.Settings.SettingNotFoundException(name);</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Convenience function for updating settings value as coma separated</div><div>     * integer values. This will either create a new entry in the table if the</div><div>     * given name does not exist, or modify the value of the existing row</div><div>     * with that name.  Note that internally setting values are always</div><div>     * stored as strings, so this function converts the given value to a</div><div>     * string before storing it.</div><div>     *</div><div>     * @param cr The ContentResolver to access.</div><div>     * @param name The name of the setting to modify.</div><div>     * @param index The index of the list</div><div>     * @param value The new value for the setting to be added to the list.</div><div>     * @return true if the value was set, false on database errors</div><div>     * @hide</div><div>     */</div><div>    public static boolean putIntAtIndex(android.content.ContentResolver cr,</div><div>            String name, int index, int value) {</div><div>        String data = &quot;&quot;;</div><div>        String valArray[] = null;</div><div>        String v = android.provider.Settings.Global.getString(cr, name);</div><div><br/></div><div>        if (index == Integer.MAX_VALUE) {</div><div>            throw new RuntimeException(&quot;putIntAtIndex index == MAX_VALUE index=&quot; + index);</div><div>        }</div><div>        if (index &lt; 0) {</div><div>            throw new RuntimeException(&quot;putIntAtIndex index &lt; 0 index=&quot; + index);</div><div>        }</div><div>        if (v != null) {</div><div>            valArray = v.split(&quot;,&quot;);</div><div>        }</div><div><br/></div><div>        // Copy the elements from valArray till index</div><div>        for (int i = 0; i &lt; index; i++) {</div><div>            String str = &quot;&quot;;</div><div>            if ((valArray != null) &amp;&amp; (i &lt; valArray.length)) {</div><div>                str = valArray[i];</div><div>            }</div><div>            data = data + str + &quot;,&quot;;</div><div>        }</div><div><br/></div><div>        data = data + value;</div><div><br/></div><div>        // Copy the remaining elements from valArray if any.</div><div>        if (valArray != null) {</div><div>            for (int i = index+1; i &lt; valArray.length; i++) {</div><div>                data = data + &quot;,&quot; + valArray[i];</div><div>            }</div><div>        }</div><div>        return android.provider.Settings.Global.putString(cr, name, data);</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Gets the telephony property.</div><div>     *</div><div>     * @hide</div><div>     */</div><div>    public static String getTelephonyProperty(int phoneId, String property, String defaultVal) {</div><div>        String propVal = null;</div><div>        String prop = SystemProperties.get(property);</div><div>        Rlog.d(TAG, &quot;getTelephonyProperty prop value= &quot; + prop);</div><div>        if ((prop != null) &amp;&amp; (prop.length() &gt; 0)) {</div><div>            String values[] = prop.split(&quot;,&quot;);</div><div>            if ((phoneId &gt;= 0) &amp;&amp; (phoneId &lt; values.length) &amp;&amp; (values[phoneId] != null)) {</div><div>                propVal = values[phoneId];</div><div>            }</div><div>        }</div><div>        Rlog.d(TAG, &quot;getTelephonyProperty: return propVal='&quot; + propVal + &quot;' phoneId=&quot; + phoneId</div><div>                + &quot; property='&quot; + property + &quot;' defaultVal='&quot; + defaultVal + &quot;' prop=&quot; + prop);</div><div>        return propVal == null ? defaultVal : propVal;</div><div>    }</div><div><br/></div><div>    /** @hide */</div><div>    public int getSimCount() {</div><div>        // FIXME Need to get it from Telephony Dev Controller when that gets implemented!</div><div>        // and then this method shouldn't be used at all!</div><div>        if(isMultiSimEnabled()) {</div><div>            return getPhoneCount();</div><div>        } else {</div><div>            return 1;</div><div>        }</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns the IMS Service Table (IST) that was loaded from the ISIM.</div><div>     * @return IMS Service Table or null if not present or not loaded</div><div>     * @hide</div><div>     */</div><div>    public String getIsimIst() {</div><div>        try {</div><div>            return getSubscriberInfo().getIsimIst();</div><div>        } catch (RemoteException ex) {</div><div>            return null;</div><div>        } catch (NullPointerException ex) {</div><div>            // This could happen before phone restarts due to crashing</div><div>            return null;</div><div>        }</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns the IMS Proxy Call Session Control Function(PCSCF) that were loaded from the ISIM.</div><div>     * @return an array of PCSCF strings with one PCSCF per string, or null if</div><div>     *         not present or not loaded</div><div>     * @hide</div><div>     */</div><div>    public String[] getIsimPcscf() {</div><div>        try {</div><div>            return getSubscriberInfo().getIsimPcscf();</div><div>        } catch (RemoteException ex) {</div><div>            return null;</div><div>        } catch (NullPointerException ex) {</div><div>            // This could happen before phone restarts due to crashing</div><div>            return null;</div><div>        }</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns the response of ISIM Authetification through RIL.</div><div>     * Returns null if the Authentification hasn't been successed or isn't present iphonesubinfo.</div><div>     * @return the response of ISIM Authetification, or null if not available</div><div>     * @hide</div><div>     * @deprecated</div><div>     * @see getIccSimChallengeResponse with appType=PhoneConstants.APPTYPE_ISIM</div><div>     */</div><div>    public String getIsimChallengeResponse(String nonce){</div><div>        try {</div><div>            return getSubscriberInfo().getIsimChallengeResponse(nonce);</div><div>        } catch (RemoteException ex) {</div><div>            return null;</div><div>        } catch (NullPointerException ex) {</div><div>            // This could happen before phone restarts due to crashing</div><div>            return null;</div><div>        }</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns the response of SIM Authentication through RIL.</div><div>     * Returns null if the Authentication hasn't been successful</div><div>     * @param subId subscription ID to be queried</div><div>     * @param appType ICC application type (@see com.android.internal.telephony.PhoneConstants#APPTYPE_xxx)</div><div>     * @param data authentication challenge data</div><div>     * @return the response of SIM Authentication, or null if not available</div><div>     * @hide</div><div>     */</div><div>    public String getIccSimChallengeResponse(int subId, int appType, String data) {</div><div>        try {</div><div>            return getSubscriberInfo().getIccSimChallengeResponse(subId, appType, data);</div><div>        } catch (RemoteException ex) {</div><div>            return null;</div><div>        } catch (NullPointerException ex) {</div><div>            // This could happen before phone starts</div><div>            return null;</div><div>        }</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns the response of SIM Authentication through RIL for the default subscription.</div><div>     * Returns null if the Authentication hasn't been successful</div><div>     * @param appType ICC application type (@see com.android.internal.telephony.PhoneConstants#APPTYPE_xxx)</div><div>     * @param data authentication challenge data</div><div>     * @return the response of SIM Authentication, or null if not available</div><div>     * @hide</div><div>     */</div><div>    public String getIccSimChallengeResponse(int appType, String data) {</div><div>        return getIccSimChallengeResponse(getDefaultSubscription(), appType, data);</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Get P-CSCF address from PCO after data connection is established or modified.</div><div>     * @param apnType the apnType, &quot;ims&quot; for IMS APN, &quot;emergency&quot; for EMERGENCY APN</div><div>     * @return array of P-CSCF address</div><div>     * @hide</div><div>     */</div><div>    public String[] getPcscfAddress(String apnType) {</div><div>        try {</div><div>            return getITelephony().getPcscfAddress(apnType);</div><div>        } catch (RemoteException e) {</div><div>            return new String[0];</div><div>        } catch (NullPointerException e) {</div><div>            Log.e(TAG, &quot;Error calling ITelephony#getPcscfAddress&quot;, e);</div><div>            return new String[0];</div><div>        }</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Set IMS registration state</div><div>     *</div><div>     * @param Registration state</div><div>     * @hide</div><div>     */</div><div>    public void setImsRegistrationState(boolean registered) {</div><div>        try {</div><div>            getITelephony().setImsRegistrationState(registered);</div><div>        } catch (RemoteException e) {</div><div>        }</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Get the preferred network type.</div><div>     * Used for device configuration by some CDMA operators.</div><div>     * &lt;p&gt;</div><div>     * Requires Permission:</div><div>     *   {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE}</div><div>     * Or the calling app has carrier privileges. @see #hasCarrierPrivileges</div><div>     *</div><div>     * @return the preferred network type, defined in RILConstants.java.</div><div>     * @hide</div><div>     */</div><div>    public int getPreferredNetworkType() {</div><div>        try {</div><div>            return getITelephony().getPreferredNetworkType();</div><div>        } catch (RemoteException ex) {</div><div>            Rlog.e(TAG, &quot;getPreferredNetworkType RemoteException&quot;, ex);</div><div>        } catch (NullPointerException ex) {</div><div>            Rlog.e(TAG, &quot;getPreferredNetworkType NPE&quot;, ex);</div><div>        }</div><div>        return -1;</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Set the preferred network type.</div><div>     * Used for device configuration by some CDMA operators.</div><div>     * &lt;p&gt;</div><div>     * Requires Permission:</div><div>     *   {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE}</div><div>     * Or the calling app has carrier privileges. @see #hasCarrierPrivileges</div><div>     *</div><div>     * @param networkType the preferred network type, defined in RILConstants.java.</div><div>     * @return true on success; false on any failure.</div><div>     * @hide</div><div>     */</div><div>    public boolean setPreferredNetworkType(int networkType) {</div><div>        try {</div><div>            return getITelephony().setPreferredNetworkType(networkType);</div><div>        } catch (RemoteException ex) {</div><div>            Rlog.e(TAG, &quot;setPreferredNetworkType RemoteException&quot;, ex);</div><div>        } catch (NullPointerException ex) {</div><div>            Rlog.e(TAG, &quot;setPreferredNetworkType NPE&quot;, ex);</div><div>        }</div><div>        return false;</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Set the preferred network type to global mode which includes LTE, CDMA, EvDo and GSM/WCDMA.</div><div>     *</div><div>     * &lt;p&gt;</div><div>     * Requires that the calling app has carrier privileges.</div><div>     * @see #hasCarrierPrivileges</div><div>     *</div><div>     * @return true on success; false on any failure.</div><div>     */</div><div>    public boolean setPreferredNetworkTypeToGlobal() {</div><div>        return setPreferredNetworkType(RILConstants.NETWORK_MODE_LTE_CDMA_EVDO_GSM_WCDMA);</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Check TETHER_DUN_REQUIRED and TETHER_DUN_APN settings, net.tethering.noprovisioning</div><div>     * SystemProperty, and config_tether_apndata to decide whether DUN APN is required for</div><div>     * tethering.</div><div>     *</div><div>     * @return 0: Not required. 1: required. 2: Not set.</div><div>     * @hide</div><div>     */</div><div>    public int getTetherApnRequired() {</div><div>        try {</div><div>            return getITelephony().getTetherApnRequired();</div><div>        } catch (RemoteException ex) {</div><div>            Rlog.e(TAG, &quot;hasMatchedTetherApnSetting RemoteException&quot;, ex);</div><div>        } catch (NullPointerException ex) {</div><div>            Rlog.e(TAG, &quot;hasMatchedTetherApnSetting NPE&quot;, ex);</div><div>        }</div><div>        return 2;</div><div>    }</div><div><br/></div><div><br/></div><div>    /**</div><div>     * Values used to return status for hasCarrierPrivileges call.</div><div>     */</div><div>    /** @hide */</div><div>    public static final int CARRIER_PRIVILEGE_STATUS_HAS_ACCESS = 1;</div><div>    /** @hide */</div><div>    public static final int CARRIER_PRIVILEGE_STATUS_NO_ACCESS = 0;</div><div>    /** @hide */</div><div>    public static final int CARRIER_PRIVILEGE_STATUS_RULES_NOT_LOADED = -1;</div><div>    /** @hide */</div><div>    public static final int CARRIER_PRIVILEGE_STATUS_ERROR_LOADING_RULES = -2;</div><div><br/></div><div>    /**</div><div>     * Has the calling application been granted carrier privileges by the carrier.</div><div>     *</div><div>     * If any of the packages in the calling UID has carrier privileges, the</div><div>     * call will return true. This access is granted by the owner of the UICC</div><div>     * card and does not depend on the registered carrier.</div><div>     *</div><div>     * @return true if the app has carrier privileges.</div><div>     */</div><div>    public boolean hasCarrierPrivileges() {</div><div>        try {</div><div>            return getITelephony().getCarrierPrivilegeStatus() ==</div><div>                CARRIER_PRIVILEGE_STATUS_HAS_ACCESS;</div><div>        } catch (RemoteException ex) {</div><div>            Rlog.e(TAG, &quot;hasCarrierPrivileges RemoteException&quot;, ex);</div><div>        } catch (NullPointerException ex) {</div><div>            Rlog.e(TAG, &quot;hasCarrierPrivileges NPE&quot;, ex);</div><div>        }</div><div>        return false;</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Override the branding for the current ICCID.</div><div>     *</div><div>     * Once set, whenever the SIM is present in the device, the service</div><div>     * provider name (SPN) and the operator name will both be replaced by the</div><div>     * brand value input. To unset the value, the same function should be</div><div>     * called with a null brand value.</div><div>     *</div><div>     * &lt;p&gt;Requires that the calling app has carrier privileges.</div><div>     * @see #hasCarrierPrivileges</div><div>     *</div><div>     * @param brand The brand name to display/set.</div><div>     * @return true if the operation was executed correctly.</div><div>     */</div><div>    public boolean setOperatorBrandOverride(String brand) {</div><div>        try {</div><div>            return getITelephony().setOperatorBrandOverride(brand);</div><div>        } catch (RemoteException ex) {</div><div>            Rlog.e(TAG, &quot;setOperatorBrandOverride RemoteException&quot;, ex);</div><div>        } catch (NullPointerException ex) {</div><div>            Rlog.e(TAG, &quot;setOperatorBrandOverride NPE&quot;, ex);</div><div>        }</div><div>        return false;</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Override the roaming preference for the current ICCID.</div><div>     *</div><div>     * Using this call, the carrier app (see #hasCarrierPrivileges) can override</div><div>     * the platform's notion of a network operator being considered roaming or not.</div><div>     * The change only affects the ICCID that was active when this call was made.</div><div>     *</div><div>     * If null is passed as any of the input, the corresponding value is deleted.</div><div>     *</div><div>     * &lt;p&gt;Requires that the caller have carrier privilege. See #hasCarrierPrivileges.</div><div>     *</div><div>     * @param gsmRoamingList - List of MCCMNCs to be considered roaming for 3GPP RATs.</div><div>     * @param gsmNonRoamingList - List of MCCMNCs to be considered not roaming for 3GPP RATs.</div><div>     * @param cdmaRoamingList - List of SIDs to be considered roaming for 3GPP2 RATs.</div><div>     * @param cdmaNonRoamingList - List of SIDs to be considered not roaming for 3GPP2 RATs.</div><div>     * @return true if the operation was executed correctly.</div><div>     *</div><div>     * @hide</div><div>     */</div><div>    public boolean setRoamingOverride(List&lt;String&gt; gsmRoamingList,</div><div>            List&lt;String&gt; gsmNonRoamingList, List&lt;String&gt; cdmaRoamingList,</div><div>            List&lt;String&gt; cdmaNonRoamingList) {</div><div>        try {</div><div>            return getITelephony().setRoamingOverride(gsmRoamingList, gsmNonRoamingList,</div><div>                    cdmaRoamingList, cdmaNonRoamingList);</div><div>        } catch (RemoteException ex) {</div><div>            Rlog.e(TAG, &quot;setRoamingOverride RemoteException&quot;, ex);</div><div>        } catch (NullPointerException ex) {</div><div>            Rlog.e(TAG, &quot;setRoamingOverride NPE&quot;, ex);</div><div>        }</div><div>        return false;</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Expose the rest of ITelephony to @SystemApi</div><div>     */</div><div><br/></div><div>    /** @hide */</div><div>    @SystemApi</div><div>    public String getCdmaMdn() {</div><div>        return getCdmaMdn(getDefaultSubscription());</div><div>    }</div><div><br/></div><div>    /** @hide */</div><div>    @SystemApi</div><div>    public String getCdmaMdn(int subId) {</div><div>        try {</div><div>            return getITelephony().getCdmaMdn(subId);</div><div>        } catch (RemoteException ex) {</div><div>            return null;</div><div>        } catch (NullPointerException ex) {</div><div>            return null;</div><div>        }</div><div>    }</div><div><br/></div><div>    /** @hide */</div><div>    @SystemApi</div><div>    public String getCdmaMin() {</div><div>        return getCdmaMin(getDefaultSubscription());</div><div>    }</div><div><br/></div><div>    /** @hide */</div><div>    @SystemApi</div><div>    public String getCdmaMin(int subId) {</div><div>        try {</div><div>            return getITelephony().getCdmaMin(subId);</div><div>        } catch (RemoteException ex) {</div><div>            return null;</div><div>        } catch (NullPointerException ex) {</div><div>            return null;</div><div>        }</div><div>    }</div><div><br/></div><div>    /** @hide */</div><div>    @SystemApi</div><div>    public int checkCarrierPrivilegesForPackage(String pkgname) {</div><div>        try {</div><div>            return getITelephony().checkCarrierPrivilegesForPackage(pkgname);</div><div>        } catch (RemoteException ex) {</div><div>            Rlog.e(TAG, &quot;checkCarrierPrivilegesForPackage RemoteException&quot;, ex);</div><div>        } catch (NullPointerException ex) {</div><div>            Rlog.e(TAG, &quot;checkCarrierPrivilegesForPackage NPE&quot;, ex);</div><div>        }</div><div>        return CARRIER_PRIVILEGE_STATUS_NO_ACCESS;</div><div>    }</div><div><br/></div><div>    /** @hide */</div><div>    @SystemApi</div><div>    public List&lt;String&gt; getCarrierPackageNamesForIntent(Intent intent) {</div><div>        try {</div><div>            return getITelephony().getCarrierPackageNamesForIntent(intent);</div><div>        } catch (RemoteException ex) {</div><div>            Rlog.e(TAG, &quot;getCarrierPackageNamesForIntent RemoteException&quot;, ex);</div><div>        } catch (NullPointerException ex) {</div><div>            Rlog.e(TAG, &quot;getCarrierPackageNamesForIntent NPE&quot;, ex);</div><div>        }</div><div>        return null;</div><div>    }</div><div><br/></div><div>    /** @hide */</div><div>    @SystemApi</div><div>    public void dial(String number) {</div><div>        try {</div><div>            getITelephony().dial(number);</div><div>        } catch (RemoteException e) {</div><div>            Log.e(TAG, &quot;Error calling ITelephony#dial&quot;, e);</div><div>        }</div><div>    }</div><div><br/></div><div>    /** @hide */</div><div>    @SystemApi</div><div>    public void call(String callingPackage, String number) {</div><div>        try {</div><div>            getITelephony().call(callingPackage, number);</div><div>        } catch (RemoteException e) {</div><div>            Log.e(TAG, &quot;Error calling ITelephony#call&quot;, e);</div><div>        }</div><div>    }</div><div><br/></div><div>    /** @hide */</div><div>    @SystemApi</div><div>    public boolean endCall() {</div><div>        try {</div><div>            return getITelephony().endCall();</div><div>        } catch (RemoteException e) {</div><div>            Log.e(TAG, &quot;Error calling ITelephony#endCall&quot;, e);</div><div>        }</div><div>        return false;</div><div>    }</div><div><br/></div><div>    /** @hide */</div><div>    @SystemApi</div><div>    public void answerRingingCall() {</div><div>        try {</div><div>            getITelephony().answerRingingCall();</div><div>        } catch (RemoteException e) {</div><div>            Log.e(TAG, &quot;Error calling ITelephony#answerRingingCall&quot;, e);</div><div>        }</div><div>    }</div><div><br/></div><div>    /** @hide */</div><div>    @SystemApi</div><div>    public void silenceRinger() {</div><div>        try {</div><div>            getTelecomService().silenceRinger();</div><div>        } catch (RemoteException e) {</div><div>            Log.e(TAG, &quot;Error calling ITelecomService#silenceRinger&quot;, e);</div><div>        }</div><div>    }</div><div><br/></div><div>    /** @hide */</div><div>    @SystemApi</div><div>    public boolean isOffhook() {</div><div>        try {</div><div>            return getITelephony().isOffhook();</div><div>        } catch (RemoteException e) {</div><div>            Log.e(TAG, &quot;Error calling ITelephony#isOffhook&quot;, e);</div><div>        }</div><div>        return false;</div><div>    }</div><div><br/></div><div>    /** @hide */</div><div>    @SystemApi</div><div>    public boolean isRinging() {</div><div>        try {</div><div>            return getITelephony().isRinging();</div><div>        } catch (RemoteException e) {</div><div>            Log.e(TAG, &quot;Error calling ITelephony#isRinging&quot;, e);</div><div>        }</div><div>        return false;</div><div>    }</div><div><br/></div><div>    /** @hide */</div><div>    @SystemApi</div><div>    public boolean isIdle() {</div><div>        try {</div><div>            return getITelephony().isIdle();</div><div>        } catch (RemoteException e) {</div><div>            Log.e(TAG, &quot;Error calling ITelephony#isIdle&quot;, e);</div><div>        }</div><div>        return true;</div><div>    }</div><div><br/></div><div>    /** @hide */</div><div>    @SystemApi</div><div>    public boolean isRadioOn() {</div><div>        try {</div><div>            return getITelephony().isRadioOn();</div><div>        } catch (RemoteException e) {</div><div>            Log.e(TAG, &quot;Error calling ITelephony#isRadioOn&quot;, e);</div><div>        }</div><div>        return false;</div><div>    }</div><div><br/></div><div>    /** @hide */</div><div>    @SystemApi</div><div>    public boolean isSimPinEnabled() {</div><div>        try {</div><div>            return getITelephony().isSimPinEnabled();</div><div>        } catch (RemoteException e) {</div><div>            Log.e(TAG, &quot;Error calling ITelephony#isSimPinEnabled&quot;, e);</div><div>        }</div><div>        return false;</div><div>    }</div><div><br/></div><div>    /** @hide */</div><div>    @SystemApi</div><div>    public boolean supplyPin(String pin) {</div><div>        try {</div><div>            return getITelephony().supplyPin(pin);</div><div>        } catch (RemoteException e) {</div><div>            Log.e(TAG, &quot;Error calling ITelephony#supplyPin&quot;, e);</div><div>        }</div><div>        return false;</div><div>    }</div><div><br/></div><div>    /** @hide */</div><div>    @SystemApi</div><div>    public boolean supplyPuk(String puk, String pin) {</div><div>        try {</div><div>            return getITelephony().supplyPuk(puk, pin);</div><div>        } catch (RemoteException e) {</div><div>            Log.e(TAG, &quot;Error calling ITelephony#supplyPuk&quot;, e);</div><div>        }</div><div>        return false;</div><div>    }</div><div><br/></div><div>    /** @hide */</div><div>    @SystemApi</div><div>    public int[] supplyPinReportResult(String pin) {</div><div>        try {</div><div>            return getITelephony().supplyPinReportResult(pin);</div><div>        } catch (RemoteException e) {</div><div>            Log.e(TAG, &quot;Error calling ITelephony#supplyPinReportResult&quot;, e);</div><div>        }</div><div>        return new int[0];</div><div>    }</div><div><br/></div><div>    /** @hide */</div><div>    @SystemApi</div><div>    public int[] supplyPukReportResult(String puk, String pin) {</div><div>        try {</div><div>            return getITelephony().supplyPukReportResult(puk, pin);</div><div>        } catch (RemoteException e) {</div><div>            Log.e(TAG, &quot;Error calling ITelephony#]&quot;, e);</div><div>        }</div><div>        return new int[0];</div><div>    }</div><div><br/></div><div>    /** @hide */</div><div>    @SystemApi</div><div>    public boolean handlePinMmi(String dialString) {</div><div>        try {</div><div>            return getITelephony().handlePinMmi(dialString);</div><div>        } catch (RemoteException e) {</div><div>            Log.e(TAG, &quot;Error calling ITelephony#handlePinMmi&quot;, e);</div><div>        }</div><div>        return false;</div><div>    }</div><div><br/></div><div>    /** @hide */</div><div>    @SystemApi</div><div>    public boolean handlePinMmiForSubscriber(int subId, String dialString) {</div><div>        try {</div><div>            return getITelephony().handlePinMmiForSubscriber(subId, dialString);</div><div>        } catch (RemoteException e) {</div><div>            Log.e(TAG, &quot;Error calling ITelephony#handlePinMmi&quot;, e);</div><div>        }</div><div>        return false;</div><div>    }</div><div><br/></div><div>    /** @hide */</div><div>    @SystemApi</div><div>    public void toggleRadioOnOff() {</div><div>        try {</div><div>            getITelephony().toggleRadioOnOff();</div><div>        } catch (RemoteException e) {</div><div>            Log.e(TAG, &quot;Error calling ITelephony#toggleRadioOnOff&quot;, e);</div><div>        }</div><div>    }</div><div><br/></div><div>    /** @hide */</div><div>    @SystemApi</div><div>    public boolean setRadio(boolean turnOn) {</div><div>        try {</div><div>            return getITelephony().setRadio(turnOn);</div><div>        } catch (RemoteException e) {</div><div>            Log.e(TAG, &quot;Error calling ITelephony#setRadio&quot;, e);</div><div>        }</div><div>        return false;</div><div>    }</div><div><br/></div><div>    /** @hide */</div><div>    @SystemApi</div><div>    public boolean setRadioPower(boolean turnOn) {</div><div>        try {</div><div>            return getITelephony().setRadioPower(turnOn);</div><div>        } catch (RemoteException e) {</div><div>            Log.e(TAG, &quot;Error calling ITelephony#setRadioPower&quot;, e);</div><div>        }</div><div>        return false;</div><div>    }</div><div><br/></div><div>    /** @hide */</div><div>    @SystemApi</div><div>    public void updateServiceLocation() {</div><div>        try {</div><div>            getITelephony().updateServiceLocation();</div><div>        } catch (RemoteException e) {</div><div>            Log.e(TAG, &quot;Error calling ITelephony#updateServiceLocation&quot;, e);</div><div>        }</div><div>    }</div><div><br/></div><div>    /** @hide */</div><div>    @SystemApi</div><div>    public boolean enableDataConnectivity() {</div><div>        try {</div><div>            return getITelephony().enableDataConnectivity();</div><div>        } catch (RemoteException e) {</div><div>            Log.e(TAG, &quot;Error calling ITelephony#enableDataConnectivity&quot;, e);</div><div>        }</div><div>        return false;</div><div>    }</div><div><br/></div><div>    /** @hide */</div><div>    @SystemApi</div><div>    public boolean disableDataConnectivity() {</div><div>        try {</div><div>            return getITelephony().disableDataConnectivity();</div><div>        } catch (RemoteException e) {</div><div>            Log.e(TAG, &quot;Error calling ITelephony#disableDataConnectivity&quot;, e);</div><div>        }</div><div>        return false;</div><div>    }</div><div><br/></div><div>    /** @hide */</div><div>    @SystemApi</div><div>    public boolean isDataConnectivityPossible() {</div><div>        try {</div><div>            return getITelephony().isDataConnectivityPossible();</div><div>        } catch (RemoteException e) {</div><div>            Log.e(TAG, &quot;Error calling ITelephony#isDataConnectivityPossible&quot;, e);</div><div>        }</div><div>        return false;</div><div>    }</div><div><br/></div><div>    /** @hide */</div><div>    @SystemApi</div><div>    public boolean needsOtaServiceProvisioning() {</div><div>        try {</div><div>            return getITelephony().needsOtaServiceProvisioning();</div><div>        } catch (RemoteException e) {</div><div>            Log.e(TAG, &quot;Error calling ITelephony#needsOtaServiceProvisioning&quot;, e);</div><div>        }</div><div>        return false;</div><div>    }</div><div><br/></div><div>    /** @hide */</div><div>    @SystemApi</div><div>    public void setDataEnabled(boolean enable) {</div><div>        setDataEnabled(SubscriptionManager.getDefaultDataSubId(), enable);</div><div>    }</div><div><br/></div><div>    /** @hide */</div><div>    @SystemApi</div><div>    public void setDataEnabled(int subId, boolean enable) {</div><div>        String pck = mContext != null ? mContext.getPackageName() : &quot;&lt;unknown&gt;&quot;;</div><div>        Log.d(TAG, &quot;setDataEnabled &quot; + enable + &quot; by &quot; + pck);</div><div>        try {</div><div>            Log.d(TAG, &quot;setDataEnabled: enabled=&quot; + enable);</div><div>            getITelephony().setDataEnabled(subId, enable);</div><div>        } catch (RemoteException e) {</div><div>            Log.e(TAG, &quot;Error calling ITelephony#setDataEnabled&quot;, e);</div><div>        } catch (NullPointerException e) {</div><div>            Log.e(TAG, &quot;Error calling ITelephony#setDataEnabled&quot;, e);</div><div>        }</div><div>    }</div><div><br/></div><div>    /** @hide */</div><div>    @SystemApi</div><div>    public boolean getDataEnabled() {</div><div>        return getDataEnabled(SubscriptionManager.getDefaultDataSubId());</div><div>    }</div><div><br/></div><div>    /** @hide */</div><div>    @SystemApi</div><div>    public boolean getDataEnabled(int subId) {</div><div>        boolean retVal = false;</div><div>        try {</div><div>            retVal = getITelephony().getDataEnabled(subId);</div><div>        } catch (RemoteException e) {</div><div>            Log.e(TAG, &quot;Error calling ITelephony#getDataEnabled&quot;, e);</div><div>        } catch (NullPointerException e) {</div><div>            Log.e(TAG, &quot;Error calling ITelephony#getDataEnabled&quot;, e);</div><div>            retVal = false;</div><div>        }</div><div>        Log.d(TAG, &quot;getDataEnabled: retVal=&quot; + retVal);</div><div>        return retVal;</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Returns the result and response from RIL for oem request</div><div>     *</div><div>     * @param oemReq the data is sent to ril.</div><div>     * @param oemResp the respose data from RIL.</div><div>     * @return negative value request was not handled or get error</div><div>     *         0 request was handled succesfully, but no response data</div><div>     *         positive value success, data length of response</div><div>     * @hide</div><div>     */</div><div>    public int invokeOemRilRequestRaw(byte[] oemReq, byte[] oemResp) {</div><div>        try {</div><div>            return getITelephony().invokeOemRilRequestRaw(oemReq, oemResp);</div><div>        } catch (RemoteException ex) {</div><div>        } catch (NullPointerException ex) {</div><div>        }</div><div>        return -1;</div><div>    }</div><div><br/></div><div>    /** @hide */</div><div>    @SystemApi</div><div>    public void enableVideoCalling(boolean enable) {</div><div>        try {</div><div>            getITelephony().enableVideoCalling(enable);</div><div>        } catch (RemoteException e) {</div><div>            Log.e(TAG, &quot;Error calling ITelephony#enableVideoCalling&quot;, e);</div><div>        }</div><div>    }</div><div><br/></div><div>    /** @hide */</div><div>    @SystemApi</div><div>    public boolean isVideoCallingEnabled() {</div><div>        try {</div><div>            return getITelephony().isVideoCallingEnabled();</div><div>        } catch (RemoteException e) {</div><div>            Log.e(TAG, &quot;Error calling ITelephony#isVideoCallingEnabled&quot;, e);</div><div>        }</div><div>        return false;</div><div>    }</div><div><br/></div><div>    /**</div><div>     * This function retrieves value for setting &quot;name+subId&quot;, and if that is not found</div><div>     * retrieves value for setting &quot;name&quot;, and if that is not found uses def as default</div><div>     *</div><div>     * @hide */</div><div>    public static int getIntWithSubId(ContentResolver cr, String name, int subId, int def) {</div><div>        return Settings.Global.getInt(cr, name + subId, Settings.Global.getInt(cr, name, def));</div><div>    }</div><div><br/></div><div>    /**</div><div>     * This function retrieves value for setting &quot;name+subId&quot;, and if that is not found</div><div>     * retrieves value for setting &quot;name&quot;, and if that is not found throws</div><div>     * SettingNotFoundException</div><div>     *</div><div>     * @hide */</div><div>    public static int getIntWithSubId(ContentResolver cr, String name, int subId)</div><div>            throws SettingNotFoundException {</div><div>        try {</div><div>            return Settings.Global.getInt(cr, name + subId);</div><div>        } catch (SettingNotFoundException e) {</div><div>            try {</div><div>                int val = Settings.Global.getInt(cr, name);</div><div>                Settings.Global.putInt(cr, name + subId, val);</div><div><br/></div><div>                /* We are now moving from 'setting' to 'setting+subId', and using the value stored</div><div>                 * for 'setting' as default. Reset the default (since it may have a user set</div><div>                 * value). */</div><div>                int default_val = val;</div><div>                if (name.equals(Settings.Global.MOBILE_DATA)) {</div><div>                    default_val = &quot;true&quot;.equalsIgnoreCase(</div><div>                            SystemProperties.get(&quot;ro.com.android.mobiledata&quot;, &quot;true&quot;)) ? 1 : 0;</div><div>                } else if (name.equals(Settings.Global.DATA_ROAMING)) {</div><div>                    default_val = &quot;true&quot;.equalsIgnoreCase(</div><div>                            SystemProperties.get(&quot;ro.com.android.dataroaming&quot;, &quot;false&quot;)) ? 1 : 0;</div><div>                }</div><div><br/></div><div>                if (default_val != val) {</div><div>                    Settings.Global.putInt(cr, name, default_val);</div><div>                }</div><div><br/></div><div>                return val;</div><div>            } catch (SettingNotFoundException exc) {</div><div>                throw new SettingNotFoundException(name);</div><div>            }</div><div>        }</div><div>    }</div><div><br/></div><div>   /**</div><div>    * Returns the IMS Registration Status</div><div>    *@hide</div><div>    */</div><div>   public boolean isImsRegistered() {</div><div>       try {</div><div>           return getITelephony().isImsRegistered();</div><div>       } catch (RemoteException ex) {</div><div>           return false;</div><div>       } catch (NullPointerException ex) {</div><div>           return false;</div><div>       }</div><div>   }</div><div><br/></div><div>   /**</div><div>    * Set TelephonyProperties.PROPERTY_ICC_OPERATOR_NUMERIC for the default phone.</div><div>    *</div><div>    * @hide</div><div>    */</div><div>    public void setSimOperatorNumeric(String numeric) {</div><div>        int phoneId = getDefaultPhone();</div><div>        setSimOperatorNumericForPhone(phoneId, numeric);</div><div>    }</div><div><br/></div><div>   /**</div><div>    * Set TelephonyProperties.PROPERTY_ICC_OPERATOR_NUMERIC for the given phone.</div><div>    *</div><div>    * @hide</div><div>    */</div><div>    public void setSimOperatorNumericForPhone(int phoneId, String numeric) {</div><div>        setTelephonyProperty(phoneId,</div><div>                TelephonyProperties.PROPERTY_ICC_OPERATOR_NUMERIC, numeric);</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Set TelephonyProperties.PROPERTY_ICC_OPERATOR_NUMERIC for the default phone.</div><div>     *</div><div>     * @hide</div><div>     */</div><div>    public void setSimOperatorName(String name) {</div><div>        int phoneId = getDefaultPhone();</div><div>        setSimOperatorNameForPhone(phoneId, name);</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Set TelephonyProperties.PROPERTY_ICC_OPERATOR_NUMERIC for the given phone.</div><div>     *</div><div>     * @hide</div><div>     */</div><div>    public void setSimOperatorNameForPhone(int phoneId, String name) {</div><div>        setTelephonyProperty(phoneId,</div><div>                TelephonyProperties.PROPERTY_ICC_OPERATOR_ALPHA, name);</div><div>    }</div><div><br/></div><div>   /**</div><div>    * Set TelephonyProperties.PROPERTY_ICC_OPERATOR_ISO_COUNTRY for the default phone.</div><div>    *</div><div>    * @hide</div><div>    */</div><div>    public void setSimCountryIso(String iso) {</div><div>        int phoneId = getDefaultPhone();</div><div>        setSimCountryIsoForPhone(phoneId, iso);</div><div>    }</div><div><br/></div><div>   /**</div><div>    * Set TelephonyProperties.PROPERTY_ICC_OPERATOR_ISO_COUNTRY for the given phone.</div><div>    *</div><div>    * @hide</div><div>    */</div><div>    public void setSimCountryIsoForPhone(int phoneId, String iso) {</div><div>        setTelephonyProperty(phoneId,</div><div>                TelephonyProperties.PROPERTY_ICC_OPERATOR_ISO_COUNTRY, iso);</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Set TelephonyProperties.PROPERTY_SIM_STATE for the default phone.</div><div>     *</div><div>     * @hide</div><div>     */</div><div>    public void setSimState(String state) {</div><div>        int phoneId = getDefaultPhone();</div><div>        setSimStateForPhone(phoneId, state);</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Set TelephonyProperties.PROPERTY_SIM_STATE for the given phone.</div><div>     *</div><div>     * @hide</div><div>     */</div><div>    public void setSimStateForPhone(int phoneId, String state) {</div><div>        setTelephonyProperty(phoneId,</div><div>                TelephonyProperties.PROPERTY_SIM_STATE, state);</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Set baseband version for the default phone.</div><div>     *</div><div>     * @param version baseband version</div><div>     * @hide</div><div>     */</div><div>    public void setBasebandVersion(String version) {</div><div>        int phoneId = getDefaultPhone();</div><div>        setBasebandVersionForPhone(phoneId, version);</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Set baseband version by phone id.</div><div>     *</div><div>     * @param phoneId for which baseband version is set</div><div>     * @param version baseband version</div><div>     * @hide</div><div>     */</div><div>    public void setBasebandVersionForPhone(int phoneId, String version) {</div><div>        if (SubscriptionManager.isValidPhoneId(phoneId)) {</div><div>            String prop = TelephonyProperties.PROPERTY_BASEBAND_VERSION +</div><div>                    ((phoneId == 0) ? &quot;&quot; : Integer.toString(phoneId));</div><div>            SystemProperties.set(prop, version);</div><div>        }</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Set phone type for the default phone.</div><div>     *</div><div>     * @param type phone type</div><div>     *</div><div>     * @hide</div><div>     */</div><div>    public void setPhoneType(int type) {</div><div>        int phoneId = getDefaultPhone();</div><div>        setPhoneType(phoneId, type);</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Set phone type by phone id.</div><div>     *</div><div>     * @param phoneId for which phone type is set</div><div>     * @param type phone type</div><div>     *</div><div>     * @hide</div><div>     */</div><div>    public void setPhoneType(int phoneId, int type) {</div><div>        if (SubscriptionManager.isValidPhoneId(phoneId)) {</div><div>            TelephonyManager.setTelephonyProperty(phoneId,</div><div>                    TelephonyProperties.CURRENT_ACTIVE_PHONE, String.valueOf(type));</div><div>        }</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Get OTASP number schema for the default phone.</div><div>     *</div><div>     * @param defaultValue default value</div><div>     * @return OTA SP number schema</div><div>     *</div><div>     * @hide</div><div>     */</div><div>    public String getOtaSpNumberSchema(String defaultValue) {</div><div>        int phoneId = getDefaultPhone();</div><div>        return getOtaSpNumberSchemaForPhone(phoneId, defaultValue);</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Get OTASP number schema by phone id.</div><div>     *</div><div>     * @param phoneId for which OTA SP number schema is get</div><div>     * @param defaultValue default value</div><div>     * @return OTA SP number schema</div><div>     *</div><div>     * @hide</div><div>     */</div><div>    public String getOtaSpNumberSchemaForPhone(int phoneId, String defaultValue) {</div><div>        if (SubscriptionManager.isValidPhoneId(phoneId)) {</div><div>            return TelephonyManager.getTelephonyProperty(phoneId,</div><div>                    TelephonyProperties.PROPERTY_OTASP_NUM_SCHEMA, defaultValue);</div><div>        }</div><div><br/></div><div>        return defaultValue;</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Get SMS receive capable from system property for the default phone.</div><div>     *</div><div>     * @param defaultValue default value</div><div>     * @return SMS receive capable</div><div>     *</div><div>     * @hide</div><div>     */</div><div>    public boolean getSmsReceiveCapable(boolean defaultValue) {</div><div>        int phoneId = getDefaultPhone();</div><div>        return getSmsReceiveCapableForPhone(phoneId, defaultValue);</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Get SMS receive capable from system property by phone id.</div><div>     *</div><div>     * @param phoneId for which SMS receive capable is get</div><div>     * @param defaultValue default value</div><div>     * @return SMS receive capable</div><div>     *</div><div>     * @hide</div><div>     */</div><div>    public boolean getSmsReceiveCapableForPhone(int phoneId, boolean defaultValue) {</div><div>        if (SubscriptionManager.isValidPhoneId(phoneId)) {</div><div>            return Boolean.valueOf(TelephonyManager.getTelephonyProperty(phoneId,</div><div>                    TelephonyProperties.PROPERTY_SMS_RECEIVE, String.valueOf(defaultValue)));</div><div>        }</div><div><br/></div><div>        return defaultValue;</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Get SMS send capable from system property for the default phone.</div><div>     *</div><div>     * @param defaultValue default value</div><div>     * @return SMS send capable</div><div>     *</div><div>     * @hide</div><div>     */</div><div>    public boolean getSmsSendCapable(boolean defaultValue) {</div><div>        int phoneId = getDefaultPhone();</div><div>        return getSmsSendCapableForPhone(phoneId, defaultValue);</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Get SMS send capable from system property by phone id.</div><div>     *</div><div>     * @param phoneId for which SMS send capable is get</div><div>     * @param defaultValue default value</div><div>     * @return SMS send capable</div><div>     *</div><div>     * @hide</div><div>     */</div><div>    public boolean getSmsSendCapableForPhone(int phoneId, boolean defaultValue) {</div><div>        if (SubscriptionManager.isValidPhoneId(phoneId)) {</div><div>            return Boolean.valueOf(TelephonyManager.getTelephonyProperty(phoneId,</div><div>                    TelephonyProperties.PROPERTY_SMS_SEND, String.valueOf(defaultValue)));</div><div>        }</div><div><br/></div><div>        return defaultValue;</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Set the alphabetic name of current registered operator.</div><div>     * @param name the alphabetic name of current registered operator.</div><div>     * @hide</div><div>     */</div><div>    public void setNetworkOperatorName(String name) {</div><div>        int phoneId = getDefaultPhone();</div><div>        setNetworkOperatorNameForPhone(phoneId, name);</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Set the alphabetic name of current registered operator.</div><div>     * @param phoneId which phone you want to set</div><div>     * @param name the alphabetic name of current registered operator.</div><div>     * @hide</div><div>     */</div><div>    public void setNetworkOperatorNameForPhone(int phoneId, String name) {</div><div>        if (SubscriptionManager.isValidPhoneId(phoneId)) {</div><div>            setTelephonyProperty(phoneId, TelephonyProperties.PROPERTY_OPERATOR_ALPHA, name);</div><div>        }</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Set the numeric name (MCC+MNC) of current registered operator.</div><div>     * @param operator the numeric name (MCC+MNC) of current registered operator</div><div>     * @hide</div><div>     */</div><div>    public void setNetworkOperatorNumeric(String numeric) {</div><div>        int phoneId = getDefaultPhone();</div><div>        setNetworkOperatorNumericForPhone(phoneId, numeric);</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Set the numeric name (MCC+MNC) of current registered operator.</div><div>     * @param phoneId for which phone type is set</div><div>     * @param operator the numeric name (MCC+MNC) of current registered operator</div><div>     * @hide</div><div>     */</div><div>    public void setNetworkOperatorNumericForPhone(int phoneId, String numeric) {</div><div>        setTelephonyProperty(phoneId, TelephonyProperties.PROPERTY_OPERATOR_NUMERIC, numeric);</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Set roaming state of the current network, for GSM purposes.</div><div>     * @param isRoaming is network in romaing state or not</div><div>     * @hide</div><div>     */</div><div>    public void setNetworkRoaming(boolean isRoaming) {</div><div>        int phoneId = getDefaultPhone();</div><div>        setNetworkRoamingForPhone(phoneId, isRoaming);</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Set roaming state of the current network, for GSM purposes.</div><div>     * @param phoneId which phone you want to set</div><div>     * @param isRoaming is network in romaing state or not</div><div>     * @hide</div><div>     */</div><div>    public void setNetworkRoamingForPhone(int phoneId, boolean isRoaming) {</div><div>        if (SubscriptionManager.isValidPhoneId(phoneId)) {</div><div>            setTelephonyProperty(phoneId, TelephonyProperties.PROPERTY_OPERATOR_ISROAMING,</div><div>                    isRoaming ? &quot;true&quot; : &quot;false&quot;);</div><div>        }</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Set the ISO country code equivalent of the current registered</div><div>     * operator's MCC (Mobile Country Code).</div><div>     * @param iso the ISO country code equivalent of the current registered</div><div>     * @hide</div><div>     */</div><div>    public void setNetworkCountryIso(String iso) {</div><div>        int phoneId = getDefaultPhone();</div><div>        setNetworkCountryIsoForPhone(phoneId, iso);</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Set the ISO country code equivalent of the current registered</div><div>     * operator's MCC (Mobile Country Code).</div><div>     * @param phoneId which phone you want to set</div><div>     * @param iso the ISO country code equivalent of the current registered</div><div>     * @hide</div><div>     */</div><div>    public void setNetworkCountryIsoForPhone(int phoneId, String iso) {</div><div>        if (SubscriptionManager.isValidPhoneId(phoneId)) {</div><div>            setTelephonyProperty(phoneId,</div><div>                    TelephonyProperties.PROPERTY_OPERATOR_ISO_COUNTRY, iso);</div><div>        }</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Set the network type currently in use on the device for data transmission.</div><div>     * @param type the network type currently in use on the device for data transmission</div><div>     * @hide</div><div>     */</div><div>    public void setDataNetworkType(int type) {</div><div>        int phoneId = getDefaultPhone();</div><div>        setDataNetworkTypeForPhone(phoneId, type);</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Set the network type currently in use on the device for data transmission.</div><div>     * @param phoneId which phone you want to set</div><div>     * @param type the network type currently in use on the device for data transmission</div><div>     * @hide</div><div>     */</div><div>    public void setDataNetworkTypeForPhone(int phoneId, int type) {</div><div>        if (SubscriptionManager.isValidPhoneId(phoneId)) {</div><div>            setTelephonyProperty(phoneId,</div><div>                    TelephonyProperties.PROPERTY_DATA_NETWORK_TYPE,</div><div>                    ServiceState.rilRadioTechnologyToString(type));</div><div>        }</div><div>    }</div><div><br/></div><div>    // Added by M begin</div><div>    /// M: For MTK multiuser in 3gdatasms:MTK_ONLY_OWNER_SIM_SUPPORT</div><div>    private IOnlyOwnerSimSupport mOnlyOwnerSimSupport = null;</div><div><br/></div><div>    /**</div><div>     * Opens a logical channel to the ICC card.</div><div>     *</div><div>     * Input parameters equivalent to TS 27.007 AT+CCHO command.</div><div>     *</div><div>     * @param AID Application id. See ETSI 102.221 and 101.220.</div><div>     * @return an IccOpenLogicalChannelResponse object.</div><div>     * @hide</div><div>     */</div><div>    public IccOpenLogicalChannelResponse iccOpenLogicalChannel(int slot, String AID) {</div><div>        try {</div><div>          return getITelephony().iccOpenLogicalChannelUsingSlot(slot, AID);</div><div>        } catch (RemoteException ex) {</div><div>        } catch (NullPointerException ex) {</div><div>        }</div><div>        return null;</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Closes a previously opened logical channel to the ICC card.</div><div>     *</div><div>     * Input parameters equivalent to TS 27.007 AT+CCHC command.</div><div>     *</div><div>     * @param channel is the channel id to be closed as retruned by a successful</div><div>     *            iccOpenLogicalChannel.</div><div>     * @return true if the channel was closed successfully.</div><div>     * @hide</div><div>     */</div><div>    public boolean iccCloseLogicalChannel(int slot, int channel) {</div><div>        try {</div><div>          return getITelephony().iccCloseLogicalChannelUsingSlot(slot, channel);</div><div>        } catch (RemoteException ex) {</div><div>        } catch (NullPointerException ex) {</div><div>        }</div><div>        return false;</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Transmit an APDU to the ICC card over a logical channel.</div><div>     *</div><div>     * Input parameters equivalent to TS 27.007 AT+CGLA command.</div><div>     *</div><div>     * @param channel is the channel id to be closed as returned by a successful</div><div>     *            iccOpenLogicalChannel.</div><div>     * @param cla Class of the APDU command.</div><div>     * @param instruction Instruction of the APDU command.</div><div>     * @param p1 P1 value of the APDU command.</div><div>     * @param p2 P2 value of the APDU command.</div><div>     * @param p3 P3 value of the APDU command. If p3 is negative a 4 byte APDU</div><div>     *            is sent to the SIM.</div><div>     * @param data Data to be sent with the APDU.</div><div>     * @return The APDU response from the ICC card with the status appended at</div><div>     *            the end. If an error occurs, an empty string is returned.</div><div>     * @hide</div><div>     */</div><div>    public String iccTransmitApduLogicalChannel(int slot, int channel, int cla,</div><div>            int instruction, int p1, int p2, int p3, String data) {</div><div>        try {</div><div>          return getITelephony().iccTransmitApduLogicalChannelUsingSlot(slot, channel, cla,</div><div>                  instruction, p1, p2, p3, data);</div><div>        } catch (RemoteException ex) {</div><div>        } catch (NullPointerException ex) {</div><div>        }</div><div>        return &quot;&quot;;</div><div>    }</div><div><br/></div><div>    /**</div><div>     * Called by NPMS</div><div>     * @param subId user preferred subId.</div><div>     * @param enabled enable/disable.</div><div>     */</div><div>    /** {@hide} */</div><div>    public void setPolicyDataEnableForSubscriber(int subId, boolean enabled) {</div><div>        try {</div><div>            getITelephony().setPolicyDataEnableForSubscriber(subId, enabled);</div><div>        } catch (RemoteException ex) {</div><div>            ex.printStackTrace();</div><div>        } catch (NullPointerException ex) {</div><div>            ex.printStackTrace();</div><div>        }</div><div>    }</div><div>    // Added by M end </div><div>}</div><div><br/></div></span>
</div></body></html> 