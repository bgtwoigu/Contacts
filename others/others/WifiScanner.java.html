<html>
<head>
  <title>WifiScanner.java</title>
  <basefont face="Microsoft YaHei" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/301769 (zh-CN); Windows/6.3.9600 (Win64);"/>
  <style>
    body, td {
      font-family: Microsoft YaHei;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="997"/>
<h1>WifiScanner.java</h1>

<div>
<span><div>/*</div><div>* Copyright (C) 2014 MediaTek Inc.</div><div>* Modification based on code covered by the mentioned copyright</div><div>* and/or permission notice(s).</div><div>*/</div><div>/*</div><div> * Copyright (C) 2008 The Android Open Source Project</div><div> *</div><div> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</div><div> * you may not use this file except in compliance with the License.</div><div> * You may obtain a copy of the License at</div><div> *</div><div> *      http://www.apache.org/licenses/LICENSE-2.0</div><div> *</div><div> * Unless required by applicable law or agreed to in writing, software</div><div> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</div><div> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</div><div> * See the License for the specific language governing permissions and</div><div> * limitations under the License.</div><div> */</div><div><br/></div><div>package android.net.wifi;</div><div><br/></div><div>import android.annotation.SystemApi;</div><div>import android.content.Context;</div><div>import android.os.Bundle;</div><div>import android.os.Handler;</div><div>import android.os.HandlerThread;</div><div>import android.os.Looper;</div><div>import android.os.Message;</div><div>import android.os.Messenger;</div><div>import android.os.Parcel;</div><div>import android.os.Parcelable;</div><div>import android.os.Process;</div><div>import android.os.RemoteException;</div><div>import android.os.SystemProperties;</div><div>import android.util.Log;</div><div>import android.util.SparseArray;</div><div><br/></div><div>import com.android.internal.util.AsyncChannel;</div><div>import com.android.internal.util.Protocol;</div><div><br/></div><div>import java.util.List;</div><div>import java.util.concurrent.CountDownLatch;</div><div><br/></div><div><br/></div><div><br/></div><div>/**</div><div> * This class provides a way to scan the Wifi universe around the device</div><div> * Get an instance of this class by calling</div><div> * {@link android.content.Context#getSystemService(String) Context.getSystemService(Context</div><div> * .WIFI_SCANNING_SERVICE)}.</div><div> * @hide</div><div> */</div><div>@SystemApi</div><div>public class WifiScanner {</div><div><br/></div><div>    /** no band specified; use channel list instead */</div><div>    public static final int WIFI_BAND_UNSPECIFIED = 0;      /* not specified */</div><div><br/></div><div>    /** 2.4 GHz band */</div><div>    public static final int WIFI_BAND_24_GHZ = 1;           /* 2.4 GHz band */</div><div>    /** 5 GHz band excluding DFS channels */</div><div>    public static final int WIFI_BAND_5_GHZ = 2;            /* 5 GHz band without DFS channels */</div><div>    /** DFS channels from 5 GHz band only */</div><div>    public static final int WIFI_BAND_5_GHZ_DFS_ONLY  = 4;  /* 5 GHz band with DFS channels */</div><div>    /** 5 GHz band including DFS channels */</div><div>    public static final int WIFI_BAND_5_GHZ_WITH_DFS  = 6;  /* 5 GHz band with DFS channels */</div><div>    /** Both 2.4 GHz band and 5 GHz band; no DFS channels */</div><div>    public static final int WIFI_BAND_BOTH = 3;             /* both bands without DFS channels */</div><div>    /** Both 2.4 GHz band and 5 GHz band; with DFS channels */</div><div>    public static final int WIFI_BAND_BOTH_WITH_DFS = 7;    /* both bands with DFS channels */</div><div><br/></div><div>    /** Minimum supported scanning period */</div><div>    public static final int MIN_SCAN_PERIOD_MS = 1000;      /* minimum supported period */</div><div>    /** Maximum supported scanning period */</div><div>    public static final int MAX_SCAN_PERIOD_MS = 1024000;   /* maximum supported period */</div><div><br/></div><div>    /** No Error */</div><div>    public static final int REASON_SUCCEEDED = 0;</div><div>    /** Unknown error */</div><div>    public static final int REASON_UNSPECIFIED = -1;</div><div>    /** Invalid listener */</div><div>    public static final int REASON_INVALID_LISTENER = -2;</div><div>    /** Invalid request */</div><div>    public static final int REASON_INVALID_REQUEST = -3;</div><div>    /** Invalid request */</div><div>    public static final int REASON_NOT_AUTHORIZED = -4;</div><div><br/></div><div>    /** @hide */</div><div>    public static final String GET_AVAILABLE_CHANNELS_EXTRA = &quot;Channels&quot;;</div><div><br/></div><div>    /**</div><div>     * Generic action callback invocation interface</div><div>     *  @hide</div><div>     */</div><div>    @SystemApi</div><div>    public static interface ActionListener {</div><div>        public void onSuccess();</div><div>        public void onFailure(int reason, String description);</div><div>    }</div><div><br/></div><div>    /**</div><div>     * gives you all the possible channels; channel is specified as an</div><div>     * integer with frequency in MHz i.e. channel 1 is 2412</div><div>     * @hide</div><div>     */</div><div>    public List&lt;Integer&gt; getAvailableChannels(int band) {</div><div>        try {</div><div>            Bundle bundle =  mService.getAvailableChannels(band);</div><div>            return bundle.getIntegerArrayList(GET_AVAILABLE_CHANNELS_EXTRA);</div><div>        } catch (RemoteException e) {</div><div>            return null;</div><div>        }</div><div>    }</div><div><br/></div><div>    /**</div><div>     * provides channel specification for scanning</div><div>     */</div><div>    public static class ChannelSpec {</div><div>        /**</div><div>         * channel frequency in MHz; for example channel 1 is specified as 2412</div><div>         */</div><div>        public int frequency;</div><div>        /**</div><div>         * if true, scan this channel in passive fashion.</div><div>         * This flag is ignored on DFS channel specification.</div><div>         * @hide</div><div>         */</div><div>        public boolean passive;                                    /* ignored on DFS channels */</div><div>        /**</div><div>         * how long to dwell on this channel</div><div>         * @hide</div><div>         */</div><div>        public int dwellTimeMS;                                    /* not supported for now */</div><div><br/></div><div>        /**</div><div>         * default constructor for channel spec</div><div>         */</div><div>        public ChannelSpec(int frequency) {</div><div>            this.frequency = frequency;</div><div>            passive = false;</div><div>            dwellTimeMS = 0;</div><div>        }</div><div>    }</div><div><br/></div><div>    /** reports {@link ScanListener#onResults} when underlying buffers are full */</div><div>    public static final int REPORT_EVENT_AFTER_BUFFER_FULL = 0;</div><div>    /** reports {@link ScanListener#onResults} after each scan */</div><div>    public static final int REPORT_EVENT_AFTER_EACH_SCAN = 1;</div><div>    /** reports {@link ScanListener#onFullResult} whenever each beacon is discovered */</div><div>    public static final int REPORT_EVENT_FULL_SCAN_RESULT = 2;</div><div><br/></div><div>    /**</div><div>     * scan configuration parameters to be sent to {@link #startBackgroundScan}</div><div>     */</div><div>    public static class ScanSettings implements Parcelable {</div><div><br/></div><div>        /** one of the WIFI_BAND values */</div><div>        public int band;</div><div>        /** list of channels; used when band is set to WIFI_BAND_UNSPECIFIED */</div><div>        public ChannelSpec[] channels;</div><div>        /** period of background scan; in millisecond, 0 =&gt; single shot scan */</div><div>        public int periodInMs;</div><div>        /** must have a valid REPORT_EVENT value */</div><div>        public int reportEvents;</div><div>        /** defines number of bssids to cache from each scan */</div><div>        public int numBssidsPerScan;</div><div><br/></div><div>        /** Implement the Parcelable interface {@hide} */</div><div>        public int describeContents() {</div><div>            return 0;</div><div>        }</div><div><br/></div><div>        /** Implement the Parcelable interface {@hide} */</div><div>        public void writeToParcel(Parcel dest, int flags) {</div><div>            dest.writeInt(band);</div><div>            dest.writeInt(periodInMs);</div><div>            dest.writeInt(reportEvents);</div><div>            dest.writeInt(numBssidsPerScan);</div><div><br/></div><div>            if (channels != null) {</div><div>                dest.writeInt(channels.length);</div><div><br/></div><div>                for (int i = 0; i &lt; channels.length; i++) {</div><div>                    dest.writeInt(channels[i].frequency);</div><div>                    dest.writeInt(channels[i].dwellTimeMS);</div><div>                    dest.writeInt(channels[i].passive ? 1 : 0);</div><div>                }</div><div>            } else {</div><div>                dest.writeInt(0);</div><div>            }</div><div>        }</div><div><br/></div><div>        /** Implement the Parcelable interface {@hide} */</div><div>        public static final Creator&lt;ScanSettings&gt; CREATOR =</div><div>                new Creator&lt;ScanSettings&gt;() {</div><div>                    public ScanSettings createFromParcel(Parcel in) {</div><div><br/></div><div>                        ScanSettings settings = new ScanSettings();</div><div>                        settings.band = in.readInt();</div><div>                        settings.periodInMs = in.readInt();</div><div>                        settings.reportEvents = in.readInt();</div><div>                        settings.numBssidsPerScan = in.readInt();</div><div>                        int num_channels = in.readInt();</div><div>                        settings.channels = new ChannelSpec[num_channels];</div><div>                        for (int i = 0; i &lt; num_channels; i++) {</div><div>                            int frequency = in.readInt();</div><div><br/></div><div>                            ChannelSpec spec = new ChannelSpec(frequency);</div><div>                            spec.dwellTimeMS = in.readInt();</div><div>                            spec.passive = in.readInt() == 1;</div><div>                            settings.channels[i] = spec;</div><div>                        }</div><div><br/></div><div>                        return settings;</div><div>                    }</div><div><br/></div><div>                    public ScanSettings[] newArray(int size) {</div><div>                        return new ScanSettings[size];</div><div>                    }</div><div>                };</div><div><br/></div><div>    }</div><div><br/></div><div>    /** @hide */</div><div>    public static class ParcelableScanResults implements Parcelable {</div><div>        public ScanResult mResults[];</div><div><br/></div><div>        public ParcelableScanResults(ScanResult[] results) {</div><div>            mResults = results;</div><div>        }</div><div><br/></div><div>        public ScanResult[] getResults() {</div><div>            return mResults;</div><div>        }</div><div><br/></div><div>        /** Implement the Parcelable interface {@hide} */</div><div>        public int describeContents() {</div><div>            return 0;</div><div>        }</div><div><br/></div><div>        /** Implement the Parcelable interface {@hide} */</div><div>        public void writeToParcel(Parcel dest, int flags) {</div><div>            if (mResults != null) {</div><div>                dest.writeInt(mResults.length);</div><div>                for (int i = 0; i &lt; mResults.length; i++) {</div><div>                    ScanResult result = mResults[i];</div><div>                    result.writeToParcel(dest, flags);</div><div>                }</div><div>            } else {</div><div>                dest.writeInt(0);</div><div>            }</div><div>        }</div><div><br/></div><div>        /** Implement the Parcelable interface {@hide} */</div><div>        public static final Creator&lt;ParcelableScanResults&gt; CREATOR =</div><div>                new Creator&lt;ParcelableScanResults&gt;() {</div><div>                    public ParcelableScanResults createFromParcel(Parcel in) {</div><div>                        int n = in.readInt();</div><div>                        ScanResult results[] = new ScanResult[n];</div><div>                        for (int i = 0; i &lt; n; i++) {</div><div>                            results[i] = ScanResult.CREATOR.createFromParcel(in);</div><div>                        }</div><div>                        return new ParcelableScanResults(results);</div><div>                    }</div><div><br/></div><div>                    public ParcelableScanResults[] newArray(int size) {</div><div>                        return new ParcelableScanResults[size];</div><div>                    }</div><div>                };</div><div>    }</div><div><br/></div><div>    /**</div><div>     * interface to get scan events on; specify this on {@link #startBackgroundScan}</div><div>     */</div><div>    public interface ScanListener extends ActionListener {</div><div>        /**</div><div>         * Framework co-ordinates scans across multiple apps; so it may not give exactly the</div><div>         * same period requested. If period of a scan is changed; it is reported by this event.</div><div>         */</div><div>        public void onPeriodChanged(int periodInMs);</div><div>        /**</div><div>         * reports results retrieved from background scan</div><div>         */</div><div>        public void onResults(ScanResult[] results);</div><div>        /**</div><div>         * reports full scan result for each access point found in scan</div><div>         */</div><div>        public void onFullResult(ScanResult fullScanResult);</div><div>    }</div><div><br/></div><div>    /** start wifi scan in background</div><div>     * @param settings specifies various parameters for the scan; for more information look at</div><div>     * {@link ScanSettings}</div><div>     * @param listener specifies the object to report events to. This object is also treated as a</div><div>     *                 key for this scan, and must also be specified to cancel the scan. Multiple</div><div>     *                 scans should also not share this object.</div><div>     */</div><div>    public void startBackgroundScan(ScanSettings settings, ScanListener listener) {</div><div>        Log.d(TAG, &quot;startBackgroundScan, pid:&quot; + Process.myPid() + &quot;, tid:&quot; + Process.myTid() + &quot;, uid:&quot; + Process.myUid());</div><div>        validateChannel();</div><div>        sAsyncChannel.sendMessage(CMD_START_BACKGROUND_SCAN, 0, putListener(listener), settings);</div><div>    }</div><div>    /**</div><div>     * stop an ongoing wifi scan</div><div>     * @param listener specifies which scan to cancel; must be same object as passed in {@link</div><div>     *  #startBackgroundScan}</div><div>     */</div><div>    public void stopBackgroundScan(ScanListener listener) {</div><div>        Log.d(TAG, &quot;stopBackgroundScan, pid:&quot; + Process.myPid() + &quot;, tid:&quot; + Process.myTid() + &quot;, uid:&quot; + Process.myUid());</div><div>        validateChannel();</div><div>        sAsyncChannel.sendMessage(CMD_STOP_BACKGROUND_SCAN, 0, removeListener(listener));</div><div>    }</div><div>    /**</div><div>     * retrieves currently available scan results</div><div>     */</div><div>    public ScanResult[] getScanResults() {</div><div>        validateChannel();</div><div>        Message reply = sAsyncChannel.sendMessageSynchronously(CMD_GET_SCAN_RESULTS, 0);</div><div><br/></div><div>        //M: google issue java.lang.ClassCastException:</div><div>        //android.net.wifi.WifiScanner$OperationResult cannot be</div><div>        //cast to android.net.wifi.ScanResult[]</div><div>        //if success reply.obj = ParcelableScanResults</div><div>        if (SystemProperties.get(&quot;wifi.gscan.dbg&quot;).equals(&quot;1&quot;)) {</div><div><br/></div><div>            ScanResult[] results = (ScanResult[]) reply.obj;</div><div>            return results;</div><div>        } else {</div><div><br/></div><div>           if(reply.what == WifiScanner.CMD_OP_SUCCEEDED){</div><div>             ScanResult[] results = ((ParcelableScanResults) reply.obj).getResults();</div><div>             return results;            </div><div><br/></div><div>           }else{</div><div>           //if fail : reply.obg = android.net.wifi.WifiScanner$OperationResult </div><div>             // ScanResult[] results = (ScanResult[]) reply.obj;</div><div>              return null;</div><div>           }</div><div>        }</div><div><br/></div><div>    }</div><div><br/></div><div>    /** specifies information about an access point of interest */</div><div>    public static class BssidInfo {</div><div>        /** bssid of the access point; in XX:XX:XX:XX:XX:XX format */</div><div>        public String bssid;</div><div>        /** low signal strength threshold; more information at {@link ScanResult#level} */</div><div>        public int low;                                            /* minimum RSSI */</div><div>        /** high signal threshold; more information at {@link ScanResult#level} */</div><div>        public int high;                                           /* maximum RSSI */</div><div>        /** channel frequency (in KHz) where you may find this BSSID */</div><div>        public int frequencyHint;</div><div>    }</div><div><br/></div><div>    /** @hide */</div><div>    @SystemApi</div><div>    public static class WifiChangeSettings implements Parcelable {</div><div>        public int rssiSampleSize;                          /* sample size for RSSI averaging */</div><div>        public int lostApSampleSize;                        /* samples to confirm AP's loss */</div><div>        public int unchangedSampleSize;                     /* samples to confirm no change */</div><div>        public int minApsBreachingThreshold;                /* change threshold to trigger event */</div><div>        public int periodInMs;                              /* scan period in millisecond */</div><div>        public BssidInfo[] bssidInfos;</div><div><br/></div><div>        /** Implement the Parcelable interface {@hide} */</div><div>        public int describeContents() {</div><div>            return 0;</div><div>        }</div><div><br/></div><div>        /** Implement the Parcelable interface {@hide} */</div><div>        public void writeToParcel(Parcel dest, int flags) {</div><div>            dest.writeInt(rssiSampleSize);</div><div>            dest.writeInt(lostApSampleSize);</div><div>            dest.writeInt(unchangedSampleSize);</div><div>            dest.writeInt(minApsBreachingThreshold);</div><div>            dest.writeInt(periodInMs);</div><div>            if (bssidInfos != null) {</div><div>                dest.writeInt(bssidInfos.length);</div><div>                for (int i = 0; i &lt; bssidInfos.length; i++) {</div><div>                    BssidInfo info = bssidInfos[i];</div><div>                    dest.writeString(info.bssid);</div><div>                    dest.writeInt(info.low);</div><div>                    dest.writeInt(info.high);</div><div>                    dest.writeInt(info.frequencyHint);</div><div>                }</div><div>            } else {</div><div>                dest.writeInt(0);</div><div>            }</div><div>        }</div><div><br/></div><div>        /** Implement the Parcelable interface {@hide} */</div><div>        public static final Creator&lt;WifiChangeSettings&gt; CREATOR =</div><div>                new Creator&lt;WifiChangeSettings&gt;() {</div><div>                    public WifiChangeSettings createFromParcel(Parcel in) {</div><div>                        WifiChangeSettings settings = new WifiChangeSettings();</div><div>                        settings.rssiSampleSize = in.readInt();</div><div>                        settings.lostApSampleSize = in.readInt();</div><div>                        settings.unchangedSampleSize = in.readInt();</div><div>                        settings.minApsBreachingThreshold = in.readInt();</div><div>                        settings.periodInMs = in.readInt();</div><div>                        int len = in.readInt();</div><div>                        settings.bssidInfos = new BssidInfo[len];</div><div>                        for (int i = 0; i &lt; len; i++) {</div><div>                            BssidInfo info = new BssidInfo();</div><div>                            info.bssid = in.readString();</div><div>                            info.low = in.readInt();</div><div>                            info.high = in.readInt();</div><div>                            info.frequencyHint = in.readInt();</div><div>                            settings.bssidInfos[i] = info;</div><div>                        }</div><div>                        return settings;</div><div>                    }</div><div><br/></div><div>                    public WifiChangeSettings[] newArray(int size) {</div><div>                        return new WifiChangeSettings[size];</div><div>                    }</div><div>                };</div><div><br/></div><div>    }</div><div><br/></div><div>    /** configure WifiChange detection</div><div>     * @param rssiSampleSize number of samples used for RSSI averaging</div><div>     * @param lostApSampleSize number of samples to confirm an access point's loss</div><div>     * @param unchangedSampleSize number of samples to confirm there are no changes</div><div>     * @param minApsBreachingThreshold minimum number of access points that need to be</div><div>     *                                 out of range to detect WifiChange</div><div>     * @param periodInMs indicates period of scan to find changes</div><div>     * @param bssidInfos access points to watch</div><div>     */</div><div>    public void configureWifiChange(</div><div>            int rssiSampleSize,                             /* sample size for RSSI averaging */</div><div>            int lostApSampleSize,                           /* samples to confirm AP's loss */</div><div>            int unchangedSampleSize,                        /* samples to confirm no change */</div><div>            int minApsBreachingThreshold,                   /* change threshold to trigger event */</div><div>            int periodInMs,                                 /* period of scan */</div><div>            BssidInfo[] bssidInfos                          /* signal thresholds to crosss */</div><div>            )</div><div>    {</div><div>        Log.d(TAG, &quot;configureWifiChange, pid:&quot; + Process.myPid() + &quot;, tid:&quot; + Process.myTid() + &quot;, uid:&quot; + Process.myUid());</div><div>        validateChannel();</div><div><br/></div><div>        WifiChangeSettings settings = new WifiChangeSettings();</div><div>        settings.rssiSampleSize = rssiSampleSize;</div><div>        settings.lostApSampleSize = lostApSampleSize;</div><div>        settings.unchangedSampleSize = unchangedSampleSize;</div><div>        settings.minApsBreachingThreshold = minApsBreachingThreshold;</div><div>        settings.periodInMs = periodInMs;</div><div>        settings.bssidInfos = bssidInfos;</div><div><br/></div><div>        configureWifiChange(settings);</div><div>    }</div><div><br/></div><div>    /**</div><div>     * interface to get wifi change events on; use this on {@link #startTrackingWifiChange}</div><div>     */</div><div>    public interface WifiChangeListener extends ActionListener {</div><div>        /** indicates that changes were detected in wifi environment</div><div>         * @param results indicate the access points that exhibited change</div><div>         */</div><div>        public void onChanging(ScanResult[] results);           /* changes are found */</div><div>        /** indicates that no wifi changes are being detected for a while</div><div>         * @param results indicate the access points that are bing monitored for change</div><div>         */</div><div>        public void onQuiescence(ScanResult[] results);         /* changes settled down */</div><div>    }</div><div><br/></div><div>    /**</div><div>     * track changes in wifi environment</div><div>     * @param listener object to report events on; this object must be unique and must also be</div><div>     *                 provided on {@link #stopTrackingWifiChange}</div><div>     */</div><div>    public void startTrackingWifiChange(WifiChangeListener listener) {</div><div>        Log.d(TAG, &quot;startTrackingWifiChange, pid:&quot; + Process.myPid() + &quot;, tid:&quot; + Process.myTid() + &quot;, uid:&quot; + Process.myUid());</div><div>        validateChannel();</div><div>        sAsyncChannel.sendMessage(CMD_START_TRACKING_CHANGE, 0, putListener(listener));</div><div>    }</div><div><br/></div><div>    /**</div><div>     * stop tracking changes in wifi environment</div><div>     * @param listener object that was provided to report events on {@link</div><div>     * #stopTrackingWifiChange}</div><div>     */</div><div>    public void stopTrackingWifiChange(WifiChangeListener listener) {</div><div>        Log.d(TAG, &quot;stopTrackingWifiChange, pid:&quot; + Process.myPid() + &quot;, tid:&quot; + Process.myTid() + &quot;, uid:&quot; + Process.myUid());</div><div>        validateChannel();</div><div>        sAsyncChannel.sendMessage(CMD_STOP_TRACKING_CHANGE, 0, removeListener(listener));</div><div>    }</div><div><br/></div><div>    /** @hide */</div><div>    @SystemApi</div><div>    public void configureWifiChange(WifiChangeSettings settings) {</div><div>        Log.d(TAG, &quot;configureWifiChange, pid:&quot; + Process.myPid() + &quot;, tid:&quot; + Process.myTid() + &quot;, uid:&quot; + Process.myUid());</div><div>        validateChannel();</div><div>        sAsyncChannel.sendMessage(CMD_CONFIGURE_WIFI_CHANGE, 0, 0, settings);</div><div>    }</div><div><br/></div><div>    /** interface to receive hotlist events on; use this on {@link #setHotlist} */</div><div>    public static interface BssidListener extends ActionListener {</div><div>        /** indicates that access points were found by on going scans</div><div>         * @param results list of scan results, one for each access point visible currently</div><div>         */</div><div>        public void onFound(ScanResult[] results);</div><div>    }</div><div><br/></div><div>    /** @hide */</div><div>    @SystemApi</div><div>    public static class HotlistSettings implements Parcelable {</div><div>        public BssidInfo[] bssidInfos;</div><div>        public int apLostThreshold;</div><div><br/></div><div>        /** Implement the Parcelable interface {@hide} */</div><div>        public int describeContents() {</div><div>            return 0;</div><div>        }</div><div><br/></div><div>        /** Implement the Parcelable interface {@hide} */</div><div>        public void writeToParcel(Parcel dest, int flags) {</div><div>            dest.writeInt(apLostThreshold);</div><div><br/></div><div>            if (bssidInfos != null) {</div><div>                dest.writeInt(bssidInfos.length);</div><div>                for (int i = 0; i &lt; bssidInfos.length; i++) {</div><div>                    BssidInfo info = bssidInfos[i];</div><div>                    dest.writeString(info.bssid);</div><div>                    dest.writeInt(info.low);</div><div>                    dest.writeInt(info.high);</div><div>                    dest.writeInt(info.frequencyHint);</div><div>                }</div><div>            } else {</div><div>                dest.writeInt(0);</div><div>            }</div><div>        }</div><div><br/></div><div>        /** Implement the Parcelable interface {@hide} */</div><div>        public static final Creator&lt;HotlistSettings&gt; CREATOR =</div><div>                new Creator&lt;HotlistSettings&gt;() {</div><div>                    public HotlistSettings createFromParcel(Parcel in) {</div><div>                        HotlistSettings settings = new HotlistSettings();</div><div>                        settings.apLostThreshold = in.readInt();</div><div>                        int n = in.readInt();</div><div>                        settings.bssidInfos = new BssidInfo[n];</div><div>                        for (int i = 0; i &lt; n; i++) {</div><div>                            BssidInfo info = new BssidInfo();</div><div>                            info.bssid = in.readString();</div><div>                            info.low = in.readInt();</div><div>                            info.high = in.readInt();</div><div>                            info.frequencyHint = in.readInt();</div><div>                            settings.bssidInfos[i] = info;</div><div>                        }</div><div>                        return settings;</div><div>                    }</div><div><br/></div><div>                    public HotlistSettings[] newArray(int size) {</div><div>                        return new HotlistSettings[size];</div><div>                    }</div><div>                };</div><div>    }</div><div><br/></div><div>    /**</div><div>     * set interesting access points to find</div><div>     * @param bssidInfos access points of interest</div><div>     * @param apLostThreshold number of scans needed to indicate that AP is lost</div><div>     * @param listener object provided to report events on; this object must be unique and must</div><div>     *                 also be provided on {@link #stopTrackingBssids}</div><div>     */</div><div>    public void startTrackingBssids(BssidInfo[] bssidInfos,</div><div>                                    int apLostThreshold, BssidListener listener) {</div><div>        Log.d(TAG, &quot;startTrackingBssids, pid:&quot; + Process.myPid() + &quot;, tid:&quot; + Process.myTid() + &quot;, uid:&quot; + Process.myUid());</div><div>        validateChannel();</div><div>        HotlistSettings settings = new HotlistSettings();</div><div>        settings.bssidInfos = bssidInfos;</div><div>        sAsyncChannel.sendMessage(CMD_SET_HOTLIST, 0, putListener(listener), settings);</div><div>    }</div><div><br/></div><div>    /**</div><div>     * remove tracking of interesting access points</div><div>     * @param listener same object provided in {@link #startTrackingBssids}</div><div>     */</div><div>    public void stopTrackingBssids(BssidListener listener) {</div><div>        Log.d(TAG, &quot;stopTrackingBssids, pid:&quot; + Process.myPid() + &quot;, tid:&quot; + Process.myTid() + &quot;, uid:&quot; + Process.myUid());</div><div>        validateChannel();</div><div>        sAsyncChannel.sendMessage(CMD_RESET_HOTLIST, 0, removeListener(listener));</div><div>    }</div><div><br/></div><div><br/></div><div>    /* private members and methods */</div><div><br/></div><div>    private static final String TAG = &quot;WifiScanner&quot;;</div><div>    private static final boolean DBG = true;</div><div><br/></div><div>    /* commands for Wifi Service */</div><div>    private static final int BASE = Protocol.BASE_WIFI_SCANNER;</div><div><br/></div><div>    /** @hide */</div><div>    public static final int CMD_SCAN                        = BASE + 0;</div><div>    /** @hide */</div><div>    public static final int CMD_START_BACKGROUND_SCAN       = BASE + 2;</div><div>    /** @hide */</div><div>    public static final int CMD_STOP_BACKGROUND_SCAN        = BASE + 3;</div><div>    /** @hide */</div><div>    public static final int CMD_GET_SCAN_RESULTS            = BASE + 4;</div><div>    /** @hide */</div><div>    public static final int CMD_SCAN_RESULT                 = BASE + 5;</div><div>    /** @hide */</div><div>    public static final int CMD_SET_HOTLIST                 = BASE + 6;</div><div>    /** @hide */</div><div>    public static final int CMD_RESET_HOTLIST               = BASE + 7;</div><div>    /** @hide */</div><div>    public static final int CMD_AP_FOUND                    = BASE + 9;</div><div>    /** @hide */</div><div>    public static final int CMD_AP_LOST                     = BASE + 10;</div><div>    /** @hide */</div><div>    public static final int CMD_START_TRACKING_CHANGE       = BASE + 11;</div><div>    /** @hide */</div><div>    public static final int CMD_STOP_TRACKING_CHANGE        = BASE + 12;</div><div>    /** @hide */</div><div>    public static final int CMD_CONFIGURE_WIFI_CHANGE       = BASE + 13;</div><div>    /** @hide */</div><div>    public static final int CMD_WIFI_CHANGE_DETECTED        = BASE + 15;</div><div>    /** @hide */</div><div>    public static final int CMD_WIFI_CHANGES_STABILIZED     = BASE + 16;</div><div>    /** @hide */</div><div>    public static final int CMD_OP_SUCCEEDED                = BASE + 17;</div><div>    /** @hide */</div><div>    public static final int CMD_OP_FAILED                   = BASE + 18;</div><div>    /** @hide */</div><div>    public static final int CMD_PERIOD_CHANGED              = BASE + 19;</div><div>    /** @hide */</div><div>    public static final int CMD_FULL_SCAN_RESULT            = BASE + 20;</div><div><br/></div><div>    private Context mContext;</div><div>    private IWifiScanner mService;</div><div><br/></div><div>    private static final int INVALID_KEY = 0;</div><div>    private static int sListenerKey = 1;</div><div><br/></div><div>    private static final SparseArray sListenerMap = new SparseArray();</div><div>    private static final Object sListenerMapLock = new Object();</div><div><br/></div><div>    private static AsyncChannel sAsyncChannel;</div><div>    private static CountDownLatch sConnected;</div><div><br/></div><div>    private static final Object sThreadRefLock = new Object();</div><div>    private static int sThreadRefCount;</div><div>    private static HandlerThread sHandlerThread;</div><div><br/></div><div>    /**</div><div>     * Create a new WifiScanner instance.</div><div>     * Applications will almost always want to use</div><div>     * {@link android.content.Context#getSystemService Context.getSystemService()} to retrieve</div><div>     * the standard {@link android.content.Context#WIFI_SERVICE Context.WIFI_SERVICE}.</div><div>     * @param context the application context</div><div>     * @param service the Binder interface</div><div>     * @hide</div><div>     */</div><div>    public WifiScanner(Context context, IWifiScanner service) {</div><div>        mContext = context;</div><div>        mService = service;</div><div>        init();</div><div>    }</div><div><br/></div><div>    private void init() {</div><div>        synchronized (sThreadRefLock) {</div><div>            if (++sThreadRefCount == 1) {</div><div>                Messenger messenger = null;</div><div>                try {</div><div>                    messenger = mService.getMessenger();</div><div>                } catch (RemoteException e) {</div><div>                    /* do nothing */</div><div>                } catch (SecurityException e) {</div><div>                    /* do nothing */</div><div>                }</div><div><br/></div><div>                if (messenger == null) {</div><div>                    sAsyncChannel = null;</div><div>                    return;</div><div>                }</div><div><br/></div><div>                sHandlerThread = new HandlerThread(&quot;WifiScanner&quot;);</div><div>                sAsyncChannel = new AsyncChannel();</div><div>                sConnected = new CountDownLatch(1);</div><div><br/></div><div>                sHandlerThread.start();</div><div>                Handler handler = new ServiceHandler(sHandlerThread.getLooper());</div><div>                sAsyncChannel.connect(mContext, handler, messenger);</div><div>                try {</div><div>                    sConnected.await();</div><div>                } catch (InterruptedException e) {</div><div>                    Log.e(TAG, &quot;interrupted wait at init&quot;);</div><div>                }</div><div>            }</div><div>        }</div><div>    }</div><div><br/></div><div>    private void validateChannel() {</div><div>        if (sAsyncChannel == null) throw new IllegalStateException(</div><div>                &quot;No permission to access and change wifi or a bad initialization&quot;);</div><div>    }</div><div><br/></div><div>    private static int putListener(Object listener) {</div><div>        if (listener == null) return INVALID_KEY;</div><div>        int key;</div><div>        synchronized (sListenerMapLock) {</div><div>            do {</div><div>                key = sListenerKey++;</div><div>            } while (key == INVALID_KEY);</div><div>            sListenerMap.put(key, listener);</div><div>        }</div><div>        return key;</div><div>    }</div><div><br/></div><div>    private static Object getListener(int key) {</div><div>        if (key == INVALID_KEY) return null;</div><div>        synchronized (sListenerMapLock) {</div><div>            Object listener = sListenerMap.get(key);</div><div>            return listener;</div><div>        }</div><div>    }</div><div><br/></div><div>    private static int getListenerKey(Object listener) {</div><div>        if (listener == null) return INVALID_KEY;</div><div>        synchronized (sListenerMapLock) {</div><div>            int index = sListenerMap.indexOfValue(listener);</div><div>            if (index == -1) {</div><div>                return INVALID_KEY;</div><div>            } else {</div><div>                return sListenerMap.keyAt(index);</div><div>            }</div><div>        }</div><div>    }</div><div><br/></div><div>    private static Object removeListener(int key) {</div><div>        if (key == INVALID_KEY) return null;</div><div>        synchronized (sListenerMapLock) {</div><div>            Object listener = sListenerMap.get(key);</div><div>            sListenerMap.remove(key);</div><div>            return listener;</div><div>        }</div><div>    }</div><div><br/></div><div>    private static int removeListener(Object listener) {</div><div>        int key = getListenerKey(listener);</div><div>        if (key == INVALID_KEY) return key;</div><div>        synchronized (sListenerMapLock) {</div><div>            sListenerMap.remove(key);</div><div>            return key;</div><div>        }</div><div>    }</div><div><br/></div><div>    /** @hide */</div><div>    public static class OperationResult implements Parcelable {</div><div>        public int reason;</div><div>        public String description;</div><div><br/></div><div>        public OperationResult(int reason, String description) {</div><div>            this.reason = reason;</div><div>            this.description = description;</div><div>        }</div><div><br/></div><div>        /** Implement the Parcelable interface {@hide} */</div><div>        public int describeContents() {</div><div>            return 0;</div><div>        }</div><div><br/></div><div>        /** Implement the Parcelable interface {@hide} */</div><div>        public void writeToParcel(Parcel dest, int flags) {</div><div>            dest.writeInt(reason);</div><div>            dest.writeString(description);</div><div>        }</div><div><br/></div><div>        /** Implement the Parcelable interface {@hide} */</div><div>        public static final Creator&lt;OperationResult&gt; CREATOR =</div><div>                new Creator&lt;OperationResult&gt;() {</div><div>                    public OperationResult createFromParcel(Parcel in) {</div><div>                        int reason = in.readInt();</div><div>                        String description = in.readString();</div><div>                        return new OperationResult(reason, description);</div><div>                    }</div><div><br/></div><div>                    public OperationResult[] newArray(int size) {</div><div>                        return new OperationResult[size];</div><div>                    }</div><div>                };</div><div>    }</div><div><br/></div><div>    private static class ServiceHandler extends Handler {</div><div>        ServiceHandler(Looper looper) {</div><div>            super(looper);</div><div>        }</div><div>        @Override</div><div>        public void handleMessage(Message msg) {</div><div>            switch (msg.what) {</div><div>                case AsyncChannel.CMD_CHANNEL_HALF_CONNECTED:</div><div>                    if (msg.arg1 == AsyncChannel.STATUS_SUCCESSFUL) {</div><div>                        sAsyncChannel.sendMessage(AsyncChannel.CMD_CHANNEL_FULL_CONNECTION);</div><div>                    } else {</div><div>                        Log.e(TAG, &quot;Failed to set up channel connection&quot;);</div><div>                        // This will cause all further async API calls on the WifiManager</div><div>                        // to fail and throw an exception</div><div>                        sAsyncChannel = null;</div><div>                    }</div><div>                    sConnected.countDown();</div><div>                    return;</div><div>                case AsyncChannel.CMD_CHANNEL_FULLY_CONNECTED:</div><div>                    return;</div><div>                case AsyncChannel.CMD_CHANNEL_DISCONNECTED:</div><div>                    Log.e(TAG, &quot;Channel connection lost&quot;);</div><div>                    // This will cause all further async API calls on the WifiManager</div><div>                    // to fail and throw an exception</div><div>                    sAsyncChannel = null;</div><div>                    getLooper().quit();</div><div>                    return;</div><div>            }</div><div><br/></div><div>            Object listener = getListener(msg.arg2);</div><div><br/></div><div>            if (listener == null) {</div><div>                if (DBG) Log.d(TAG, &quot;invalid listener key = &quot; + msg.arg2);</div><div>                return;</div><div>            } else {</div><div>                if (DBG) Log.d(TAG, &quot;listener key = &quot; + msg.arg2);</div><div>            }</div><div><br/></div><div>            switch (msg.what) {</div><div>                    /* ActionListeners grouped together */</div><div>                case CMD_OP_SUCCEEDED :</div><div>                    ((ActionListener) listener).onSuccess();</div><div>                    break;</div><div>                case CMD_OP_FAILED : {</div><div>                        OperationResult result = (OperationResult)msg.obj;</div><div>                        ((ActionListener) listener).onFailure(result.reason, result.description);</div><div>                        removeListener(msg.arg2);</div><div>                    }</div><div>                    break;</div><div>                case CMD_SCAN_RESULT :</div><div>                    ((ScanListener) listener).onResults(</div><div>                            ((ParcelableScanResults) msg.obj).getResults());</div><div>                    return;</div><div>                case CMD_FULL_SCAN_RESULT :</div><div>                    ScanResult result = (ScanResult) msg.obj;</div><div>                    ((ScanListener) listener).onFullResult(result);</div><div>                    return;</div><div>                case CMD_PERIOD_CHANGED:</div><div>                    ((ScanListener) listener).onPeriodChanged(msg.arg1);</div><div>                    return;</div><div>                case CMD_AP_FOUND:</div><div>                    ((BssidListener) listener).onFound(</div><div>                            ((ParcelableScanResults) msg.obj).getResults());</div><div>                    return;</div><div>                case CMD_WIFI_CHANGE_DETECTED:</div><div>                    ((WifiChangeListener) listener).onChanging(</div><div>                            ((ParcelableScanResults) msg.obj).getResults());</div><div>                   return;</div><div>                case CMD_WIFI_CHANGES_STABILIZED:</div><div>                    ((WifiChangeListener) listener).onQuiescence(</div><div>                            ((ParcelableScanResults) msg.obj).getResults());</div><div>                    return;</div><div>                default:</div><div>                    if (DBG) Log.d(TAG, &quot;Ignoring message &quot; + msg.what);</div><div>                    return;</div><div>            }</div><div>        }</div><div>    }</div><div>}</div><div><br/></div></span>
</div></body></html> 